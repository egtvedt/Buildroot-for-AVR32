 CHANGELOG                                         |  309 +++++++++++++
 MAINTAINERS                                       |    6 +-
 MAKEALL                                           |    5 +
 Makefile                                          |   49 ++-
 README                                            |    4 +-
 board/amcc/sequoia/cmd_sequoia.c                  |   17 +-
 board/amcc/sequoia/sequoia.c                      |    7 +-
 board/amcc/yosemite/yosemite.c                    |    7 +-
 board/atmel/atngw100/Makefile                     |   40 ++
 board/atmel/atngw100/atngw100.c                   |   73 +++
 board/atmel/atngw100/config.mk                    |    3 +
 board/atmel/atngw100/eth.c                        |   36 ++
 board/atmel/atngw100/flash.c                      |  236 ++++++++++
 board/atmel/atngw100/u-boot.lds                   |   80 ++++
 board/freescale/common/pq-mds-pib.c               |   26 +-
 board/innokom/innokom.c                           |    2 +-
 board/motionpro/motionpro.c                       |    6 +
 board/pxa255_idp/Makefile                         |    2 +-
 board/pxa255_idp/config.mk                        |    2 +-
 board/pxa255_idp/lowlevel_init.S                  |  496 +++++++++++++++++++++
 board/pxa255_idp/memsetup.S                       |  496 ---------------------
 board/pxa255_idp/u-boot.lds                       |    1 +
 board/tqm5200/cmd_stk52xx.c                       |   17 +-
 board/tqm5200/tqm5200.c                           |    2 +
 board/tqm8xx/tqm8xx.c                             |   16 +-
 board/xsengine/flash.c                            |    4 +-
 common/cmd_bootm.c                                |    2 +-
 common/cmd_dtt.c                                  |    2 +-
 cpu/arm920t/at91rm9200/usb.c                      |    8 +-
 cpu/at32ap/at32ap7000/Makefile                    |   43 --
 cpu/at32ap/at32ap7000/gpio.c                      |  137 ------
 cpu/at32ap/at32ap700x/Makefile                    |   43 ++
 cpu/at32ap/at32ap700x/gpio.c                      |  144 ++++++
 cpu/at32ap/atmel_mci.c                            |   13 +-
 cpu/mpc86xx/spd_sdram.c                           |   30 +-
 cpu/pxa/config.mk                                 |    3 +-
 cpu/pxa/serial.c                                  |   72 ++--
 cpu/pxa/start.S                                   |    6 +-
 cpu/pxa/usb.c                                     |   23 +-
 drivers/Makefile                                  |   29 +-
 drivers/ds1722.c                                  |    4 +-
 drivers/fsl_pci_init.c                            |    8 +
 drivers/isp116x-hcd.c                             |  112 +++--
 drivers/mw_eeprom.c                               |    4 +-
 drivers/ne2000.c                                  |   38 +--
 drivers/ne2000.h                                  |    2 +-
 include/asm-avr32/arch-at32ap7000/clk.h           |   70 ---
 include/asm-avr32/arch-at32ap7000/gpio.h          |  212 ---------
 include/asm-avr32/arch-at32ap7000/hmatrix2.h      |  232 ----------
 include/asm-avr32/arch-at32ap7000/memory-map.h    |   66 ---
 include/asm-avr32/arch-at32ap7000/mmc.h           |   96 ----
 include/asm-avr32/arch-at32ap700x/chip-features.h |   34 ++
 include/asm-avr32/arch-at32ap700x/clk.h           |   78 ++++
 include/asm-avr32/arch-at32ap700x/gpio.h          |  220 +++++++++
 include/asm-avr32/arch-at32ap700x/hmatrix2.h      |  232 ++++++++++
 include/asm-avr32/arch-at32ap700x/memory-map.h    |   66 +++
 include/asm-avr32/arch-at32ap700x/mmc.h           |   96 ++++
 include/asm-mips/string.h                         |   10 +-
 include/configs/MPC8266ADS.h                      |   51 +--
 include/configs/TQM5200.h                         |    6 +-
 include/configs/TQM860M.h                         |   13 +-
 include/configs/TQM866M.h                         |   49 ++-
 include/configs/atngw100.h                        |  181 ++++++++
 include/configs/atstk1002.h                       |   11 +-
 include/configs/atstk1003.h                       |  184 ++++++++
 include/configs/atstk1004.h                       |  185 ++++++++
 include/configs/delta.h                           |    2 +
 include/configs/lubbock.h                         |    1 +
 include/configs/motionpro.h                       |   29 +-
 include/configs/pxa255_idp.h                      |   13 +-
 include/configs/sequoia.h                         |    2 +
 include/configs/xsengine.h                        |    1 +
 include/configs/xupv2p.h                          |   36 +-
 include/configs/yosemite.h                        |    2 +
 include/part.h                                    |    6 +-
 net/eth.c                                         |    4 +
 76 files changed, 3182 insertions(+), 1671 deletions(-)
 create mode 100644 board/atmel/atngw100/Makefile
 create mode 100644 board/atmel/atngw100/atngw100.c
 create mode 100644 board/atmel/atngw100/config.mk
 create mode 100644 board/atmel/atngw100/eth.c
 create mode 100644 board/atmel/atngw100/flash.c
 create mode 100644 board/atmel/atngw100/u-boot.lds
 create mode 100644 board/pxa255_idp/lowlevel_init.S
 delete mode 100644 board/pxa255_idp/memsetup.S
 delete mode 100644 cpu/at32ap/at32ap7000/Makefile
 delete mode 100644 cpu/at32ap/at32ap7000/gpio.c
 create mode 100644 cpu/at32ap/at32ap700x/Makefile
 create mode 100644 cpu/at32ap/at32ap700x/gpio.c
 delete mode 100644 include/asm-avr32/arch-at32ap7000/clk.h
 delete mode 100644 include/asm-avr32/arch-at32ap7000/gpio.h
 delete mode 100644 include/asm-avr32/arch-at32ap7000/hmatrix2.h
 delete mode 100644 include/asm-avr32/arch-at32ap7000/memory-map.h
 delete mode 100644 include/asm-avr32/arch-at32ap7000/mmc.h
 create mode 100644 include/asm-avr32/arch-at32ap700x/chip-features.h
 create mode 100644 include/asm-avr32/arch-at32ap700x/clk.h
 create mode 100644 include/asm-avr32/arch-at32ap700x/gpio.h
 create mode 100644 include/asm-avr32/arch-at32ap700x/hmatrix2.h
 create mode 100644 include/asm-avr32/arch-at32ap700x/memory-map.h
 create mode 100644 include/asm-avr32/arch-at32ap700x/mmc.h
 create mode 100644 include/configs/atngw100.h
 create mode 100644 include/configs/atstk1003.h
 create mode 100644 include/configs/atstk1004.h

diff --git a/CHANGELOG b/CHANGELOG
index b038749..549c4f9 100644
--- a/CHANGELOG
+++ b/CHANGELOG
@@ -1,3 +1,267 @@
+commit 58b74b05c621e2835ecf4e2d3243042cf4186777
+Author: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
+Date:	Fri Oct 19 00:09:05 2007 +0200
+
+    Fix missing drivers makefile entries ds1722.c mw_eeprom.c
+
+    Signed-off-by: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
+
+commit 96455bfebc9887837095c9051d216f53c61b5f10
+Author: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
+Date:	Fri Oct 19 00:07:39 2007 +0200
+
+    Fix warning differ in signedness in board/innokom/innokom.c
+
+    Signed-off-by: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
+
+commit 2a4741d9a14ec475f50e9856d2c0a67e8b4271bd
+Author: Marcel Ziswiler <marcel@ziswiler.com>
+Date:	Fri Oct 19 00:25:33 2007 +0200
+
+    fix pxa255_idp board
+
+    The pxa255_idp being an old unmaintained board showed several issues:
+    1. CONFIG_INIT_CRITICAL was still defined.
+    2. Neither CONFIG_MAC_PARTITION nor CONFIG_DOS_PARTITION was defined.
+    3. Symbol flash_addr was undeclared.
+    4. The boards lowlevel_init function was still called memsetup.
+    5. The TEXT_BASE was still 0xa3000000 rather than 0xa3080000.
+    6. Using -march=armv5 instead of -march=armv5te resulted in lots of
+    'target CPU does not support interworking' warnings on recent compilers.
+    7. The PXA's serial driver redefined FFUART, BTUART and STUART used as
+    indexes rather than the register definitions from the pxa-regs header
+    file. Renamed them to FFUART_INDEX, BTUART_INDEX and STUART_INDEX to
+    avoid any ambiguities.
+    8. There were several redefinition warnings concerning ICMR, OSMR3,
+    OSCR, OWER, OIER, RCSR and CCCR in the PXA's assembly start file.
+    9. The board configuration file was rather outdated.
+    10. The part header file defined the vendor, product and revision arrays
+    as unsigned chars instead of just chars in the block_dev_desc_t
+    structure.
+
+    Signed-off-by: Marcel Ziswiler <marcel@ziswiler.com>
+
+commit 298cd4cafe81ff8a6c87be8fbc440a20720d3ed6
+Author: Rune Torgersen <runet@innovsys.com>
+Date:	Wed Oct 17 11:56:31 2007 -0500
+
+    Make MPC8266ADS command selection more robust
+
+    Fix MPC8266 command line definition so it won't break when new commands
+    are added to u-boot.
+    Signed-off-by Rune Torgersen <runet@innovsys.com>
+
+commit 05bf4919c1ce49cdedadacd564d0786a8ed796a1
+Author: Wolfgang Denk <wd@denx.de>
+Date:	Sun Oct 21 01:01:17 2007 +0200
+
+    Minor coding style cleanup; update CHANGELOG
+
+    Signed-off-by: Wolfgang Denk <wd@denx.de>
+
+commit ff285ca07eda1ea4a8909848cc1cc604ec8fec9c
+Author: Vlad Lungu <vlad@comsys.ro>
+Date:	Thu Oct 4 20:47:10 2007 +0300
+
+    Fix NE2000 driver:
+
+    Fixed typo in ne2000.h, thinko re n2k_inb() usage, don't try
+    to do anything in eth_stop() if eth_init() was not called.
+    Simplified RX path in order to avoid timeouts on really really
+    fast NE2000 cards (read: qemu with internal tftp), NetLoop() is
+    clever enough to cope with 1 packet per eth_rx().
+
+    Signed-off-by: Vlad Lungu <vlad@comsys.ro>
+
+commit 5441f61a3d8b7034f19fc1361183e936198e6dbb
+Author: Detlev Zundel <dzu@denx.de>
+Date:	Fri Oct 19 16:47:26 2007 +0200
+
+    Fix two typos.
+
+    Signed-off-by: Detlev Zundel <dzu@denx.de>
+
+commit 281df457c1aa50d2752165d0c5c3282d4027b974
+Author: Tony Li <tony.li@freescale.com>
+Date:	Thu Oct 18 17:47:19 2007 +0800
+
+    mpc83xx: Add configure entry for MPC83xx ATM support
+
+    Add MPC8360EMDS_ATM_config and MPC832XEMDS_ATM_config into
+    Makfile and MAKEALL
+
+    Signed-off-by: Tony Li <tony.li@freescale.com>
+    Signed-off-by: Kim Phillips <kim.phillips@freescale.com>
+
+commit d2646554f529a9577515eceb0ec5eceee18244ba
+Author: Tony Li <tony.li@freescale.com>
+Date:	Thu Oct 18 17:44:38 2007 +0800
+
+    mpc83xx: pq-mds-pib.c typo error
+
+    Correct to val8 from val.
+
+    Signed-off-by: Tony Li <tony.li@freescale.com>
+    Signed-off-by: Kim Phillips <kim.phillips@freescale.com>
+
+commit 3e11ae80fec1ee12194940955431186abf6009c2
+Author: Stefan Roese <sr@denx.de>
+Date:	Wed Oct 17 15:40:19 2007 +0200
+
+    ppc4xx: Add 667/133 (CPU/PLB) frequency setup to Sequoia bootstrap command
+
+    Signed-off-by: Stefan Roese <sr@denx.de>
+
+commit 7ee6ba1a056e4061ab4cfde30127e332e7957afd
+Author: runet@innovsys.com <runet@innovsys.com>
+Date:	Tue Oct 16 14:50:40 2007 -0500
+
+    Make MPC8266ADS board compile again.
+
+    Signed-off-by: Runet Torgersen <runet@innovsys.com>
+
+commit 2491167c245d8ebe6f2dbd8c4287aaa0d14fe93a
+Author: Jon Loeliger <jdl@freescale.com>
+Date:	Mon Aug 27 12:41:03 2007 -0500
+
+    86xx: Allow for fewer DDR slots per memory controller.
+
+    As a direct correlation exists between DDR DIMM slots
+    and SPD EEPROM addresses used to configure them, use
+    the individually defined SPD_EEPROM_ADDRESS* values to
+    determine if a DDR DIMM slot should have its SPD
+    configuration read or not.
+
+    Effectively, this now allows for 1 or 2 DIMM slots
+    per memory controller.
+
+    Signed-off-by: Jon Loeliger <jdl@freescale.com>
+
+commit 4d4a945e189a2f384c66432316da2788a0ac1607
+Author: Rodolfo Giometti <giometti@enneenne.com>
+Date:	Mon Oct 15 11:59:17 2007 +0200
+
+    PXA USB OHCI: "usb stop" implementation.
+
+    Some USB keys need to be switched off before loading the kernel
+    otherwise they can remain in an undefined status which prevents them
+    to be correctly recognized by the kernel.
+
+    Signed-off-by: Rodolfo Giometti <giometti@linux.it>
+
+commit e2e93442e558cf1500e92861f99713b2f045ea22
+Author: Stefan Roese <sr@denx.de>
+Date:	Mon Oct 15 11:39:00 2007 +0200
+
+    ppc4xx: Fix bug in I2C bootstrap values for Sequoia/Rainier
+
+    The I2C bootstrap values that can be setup via the "bootstrap" command,
+    were setup incorrect regarding the generation of the internal sync PCI
+    clock. The values for PLB clock == 133MHz were slighly incorrect and the
+    values for PLB clock == 166MHz were totally incorrect. This could
+    lead to a hangup upon booting while PCI configuration scan.
+
+    This patch fixes this issue and configures valid PCI divisor values
+    for the sync PCI clock, with respect to the provided external async
+    PCI frequency.
+
+    Here the values of the formula in the chapter 14.2 "PCI clocking"
+    from the 440EPx users manual:
+
+    AsyncPCICLK - 1MHz <= SyncPCIClk <= (2 * AsyncPCIClk) - 1MHz
+
+    33MHz async PCI frequency:
+    PLB = 133:
+    =>	    32 <= 44.3 <= 65	    (div = 3)
+
+    PLB = 166:
+    =>	    32 <= 55.3 <= 65	    (div = 3)
+
+    66MHz async PCI frequency:
+    PLB = 133:
+    =>	    65 <= 66.5 <= 132	    (div = 2)
+
+    PLB = 166:
+    =>	    65 <= 83 <= 132	    (div = 2)
+
+    Signed-off-by: Stefan Roese <sr@denx.de>
+
+commit 5a5958b7de70ae99f0e7cbd5c97ec1346e051587
+Author: Stefan Roese <sr@denx.de>
+Date:	Mon Oct 15 11:29:33 2007 +0200
+
+    ppc4xx: Fix incorrect 33/66MHz PCI clock log-message on Sequoia & Yosemite
+
+    The BCSR status bit for the 66MHz PCI operation was correctly
+    addressed (MSB/LSB problem). Now the correct currently setup
+    PCI frequency is displayed upon bootup.
+
+    This patch also fixes this problem on Rainier & Yellowstone, since these
+    boards use the same souce code as Sequoia & Yosemite do.
+
+    Signed-off-by: Stefan Roese <sr@denx.de>
+
+commit da3aad55cbde80ab6e301aafa82a2c411aa53eff
+Author: Martin Krause <martin.krause@tqs.de>
+Date:	Wed Sep 26 17:55:56 2007 +0200
+
+    TQM860M: adjust for doubled flash sector size.
+
+    Adjust flash map to support the new S29GLxxN (N-Type) Flashes with
+    doubled sector size.
+
+    Signed-off-by: Martin Krause <martin.krause@tqs.de>
+
+commit 9d29250e2e62f4bf20c7a20b4173d84c48f11f5d
+Author: Jens Gehrlein <jens.gehrlein@tqs.de>
+Date:	Wed Sep 26 17:55:54 2007 +0200
+
+    TQM8xx: Fix CAN timing.
+
+    Signed-off-by: Martin Krause <martin.krause@tqs.de>
+
+commit d43e489baf02afae49077791fb22332d240d8656
+Author: Martin Krause <martin.krause@tqs.de>
+Date:	Thu Sep 27 14:54:36 2007 +0200
+
+    TQM866M: fix SDRAM refresh
+
+    At 133 MHz the current SDRAM refresh rate is too fast
+    (measured 4 * 1.17 us).
+    CFG_MAMR_PTA changes from 39 to 97. This result
+    in a refresh rate of 4 * 7.8 us at the default clock
+    50 MHz. At 133 MHz the value will be then 4 * 2.9 us.
+    This is a compromise until a new method is found to
+    adjust the refresh rate.
+
+    Signed-off-by: Martin Krause <martin.krause@tqs.de>
+
+commit 9ef57bbee1c67cc01da2026c242c4692db32be36
+Author: Martin Krause <martin.krause@tqs.de>
+Date:	Wed Sep 26 17:55:55 2007 +0200
+
+    TQM866M: adjust for doubled flash sector size.
+
+    Adjust flash map to support the new S29GLxxN (N-Type) Flashes with
+    doubled sector size.
+
+    Signed-off-by: Martin Krause <martin.krause@tqs.de>
+
+commit f8bf90461d9bad2e6fed31fcebaf235f60dd6763
+Author: Michal Simek <monstr@monstr.eu>
+Date:	Sun Oct 14 16:12:29 2007 +0200
+
+    [FIX] XUPV2P change command handling
+    and remove code violation
+
+commit 636400198228d96983c06657b17f760f5989958e
+Author: Wolfgang Denk <wd@denx.de>
+Date:	Sun Oct 14 00:13:19 2007 +0200
+
+    Prepare for 1.3.0-rc3 release
+
+    Signed-off-by: Wolfgang Denk <wd@denx.de>
+
 commit 68f14f77ca5fe5f9cc025c8cae101671f628309f
 Author: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
 Date:	Sat Sep 29 13:41:37 2007 +0200
@@ -109,6 +373,26 @@ Date:	Mon Oct 1 09:51:50 2007 +0200
 
     Signed-off-by: Grzegorz Bernacki <gjb@semihalf.com>
 
+commit 785c13477b77dcd2e6c5128fffcdb4e1943f4818
+Author: Timo Ketola <timo.ketola@exertus.fi>
+Date:	Mon Sep 24 14:50:32 2007 +0300
+
+    Bugfix: Use only one PTD for one endpoint
+
+    Original isp116x-hcd code prepared multiple PTDs for longer than 16
+    byte transfers for one endpoint. That is unnecessary because the
+    ISP116x is able to split long data from one PTD into multiple
+    transactions based on the buffer size of the endpoint. It also caused
+    serious problems if the endpoint NAKed some of the transactions. In
+    that case ISP116x wouldn't notice that the other PTDs were for the same
+    endpoint and would try the other PTDs possibly out of order. That would
+    break the whole transfer.
+
+    This patch makes isp116x_submit_job to use one PTD for one transfer.
+
+    Signed-off-by: Timo Ketola <timo.ketola@exertus.fi>
+    Signed-off-by: Markus Klotzbuecher <mk@denx.de>
+
 commit 86ec86c04326c3913178a7679aa910de071da75d
 Author: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
 Date:	Thu Sep 27 23:27:47 2007 +0200
@@ -331,6 +615,12 @@ Date:	Mon Sep 10 17:13:49 2007 +0900
 
     Signed-off-by: Kyungmin Park <kyungmin.park@samsung.com>
 
+commit b49c90df6e7cfcfb8b862b8bbf8448dff5eed9a5
+Author: Michal Simek <monstr@monstr.eu>
+Date:	Sun Sep 16 20:51:57 2007 +0200
+
+    [FIX] remove files form repository
+
 commit 67c31036acaaaa992fc346cc89db0909a7e733c4
 Author: Wolfgang Denk <wd@denx.de>
 Date:	Sun Sep 16 17:10:04 2007 +0200
@@ -478,6 +768,25 @@ Date:	Sat Sep 15 11:55:42 2007 +0200
 
     [1] http://article.gmane.org/gmane.comp.boot-loaders.u-boot/31805
 
+commit 991b089d1ce5ad945725e3657a8f106dfa02a38e
+Author: Michal Simek <monstr@monstr.eu>
+Date:	Sat Sep 15 00:03:35 2007 +0200
+
+    Synchronize with U-BOOT mainline
+
+commit d7fee32b7e61fe11c64e371cde79faa4768e8350
+Author: Sam Sparks <SSparks@twacs.com>
+Date:	Fri Sep 14 11:14:42 2007 -0600
+
+    Update MPC8349ITX*_config to place config.tmp in right place.
+
+    MPC834ITX*_config does not store config.tmp at the correct locatation,
+    causing MPC8349ITXGP to have the wrong TEXT_BASE.
+
+    Signed-off-by: Sam Sparks <SSparks@twacs.com>
+    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
+    Signed-off-by: Kim Phillips <kim.phillips@freescale.com>
+
 commit 6e7b7b6ea1b6d04dbe96242eb6a0c1c664c98e8c
 Author: Bartlomiej Sieka <tur@semihalf.com>
 Date:	Thu Sep 13 18:21:48 2007 +0200
diff --git a/MAINTAINERS b/MAINTAINERS
index b8c1fdc..457dce3 100644
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@ -630,7 +630,11 @@ Hayden Fraser <Hayden.Fraser@freescale.com>
 
 Haavard Skinnemoen <hskinnemoen@atmel.com>
 
-	ATSTK1000		AT32AP7000
+	ATSTK1000		AT32AP7xxx
+	ATSTK1002		AT32AP7000
+	ATSTK1003		AT32AP7001
+	ATSTK1004		AT32AP7002
+	ATNGW100		AT32AP7000
 
 #########################################################################
 # End of MAINTAINERS list						#
diff --git a/MAKEALL b/MAKEALL
index 2597d1f..a174dd2 100755
--- a/MAKEALL
+++ b/MAKEALL
@@ -301,10 +301,12 @@ LIST_83xx="		\
 	MPC8313ERDB_66	\
 	MPC8323ERDB	\
 	MPC832XEMDS	\
+	MPC832XEMDS_ATM	\
 	MPC8349EMDS	\
 	MPC8349ITX	\
 	MPC8349ITXGP	\
 	MPC8360EMDS	\
+	MPC8360EMDS_ATM	\
 	sbc8349		\
 	TQM834x		\
 "
@@ -638,6 +640,9 @@ LIST_coldfire="			\
 
 LIST_avr32="		\
 	atstk1002	\
+	atstk1003	\
+	atstk1004	\
+	atngw100	\
 "
 
 #########################################################################
diff --git a/Makefile b/Makefile
index e1cea0d..eb82d56 100644
--- a/Makefile
+++ b/Makefile
@@ -24,7 +24,7 @@
 VERSION = 1
 PATCHLEVEL = 3
 SUBLEVEL = 0
-EXTRAVERSION = -rc3
+EXTRAVERSION = -rc3.atmel.1
 U_BOOT_VERSION = $(VERSION).$(PATCHLEVEL).$(SUBLEVEL)$(EXTRAVERSION)
 VERSION_FILE = $(obj)include/version_autogenerated.h
 
@@ -393,7 +393,7 @@ BC3450_config:	unconfig
 cpci5200_config:  unconfig
 	@$(MKCONFIG) -a cpci5200  ppc mpc5xxx cpci5200 esd
 
-hmi1001_config:         unconfig
+hmi1001_config:	unconfig
 	@$(MKCONFIG) hmi1001 ppc mpc5xxx hmi1001
 
 Lite5200_config				\
@@ -435,7 +435,7 @@ icecube_5100_config:			unconfig
 		}
 	@$(MKCONFIG) -a IceCube ppc mpc5xxx icecube
 
-jupiter_config:         unconfig
+jupiter_config:	unconfig
 	@$(MKCONFIG) jupiter ppc mpc5xxx jupiter
 
 v38b_config: unconfig
@@ -640,9 +640,9 @@ TQM5200_STK100_config:	unconfig
 		{ echo "TEXT_BASE = 0xFFF00000" >$(obj)board/tqm5200/config.tmp ; \
 		}
 	@$(MKCONFIG) -n $@ -a TQM5200 ppc mpc5xxx tqm5200
-uc101_config:         unconfig
+uc101_config:		unconfig
 	@$(MKCONFIG) uc101 ppc mpc5xxx uc101
-motionpro_config:         unconfig
+motionpro_config:	unconfig
 	@$(MKCONFIG) motionpro ppc mpc5xxx motionpro
 
 
@@ -930,7 +930,7 @@ RPXlite_DW_NVRAM_config		\
 RPXlite_DW_NVRAM_64_config      \
 RPXlite_DW_NVRAM_LCD_config	\
 RPXlite_DW_NVRAM_64_LCD_config  \
-RPXlite_DW_config:         unconfig
+RPXlite_DW_config:	unconfig
 	@mkdir -p $(obj)include
 	@ >$(obj)include/config.h
 	@[ -z "$(findstring _64,$@)" ] || \
@@ -1766,7 +1766,8 @@ MPC8323ERDB_config:	unconfig
 MPC832XEMDS_config \
 MPC832XEMDS_HOST_33_config \
 MPC832XEMDS_HOST_66_config \
-MPC832XEMDS_SLAVE_config:	unconfig
+MPC832XEMDS_SLAVE_config \
+MPC832XEMDS_ATM_config:	unconfig
 	@mkdir -p $(obj)include
 	@echo "" >$(obj)include/config.h ; \
 	if [ "$(findstring _HOST_,$@)" ] ; then \
@@ -1781,10 +1782,17 @@ MPC832XEMDS_SLAVE_config:	unconfig
 	if [ "$(findstring _33_,$@)" ] ; then \
 		echo -n "...33M ..." ; \
 		echo "#define PCI_33M" >>$(obj)include/config.h ; \
+		echo "#define CONFIG_PQ_MDS_PIB 1" >>$(obj)include/config.h ; \
 	fi ; \
 	if [ "$(findstring _66_,$@)" ] ; then \
 		echo -n "...66M..." ; \
 		echo "#define PCI_66M" >>$(obj)include/config.h ; \
+		echo "#define CONFIG_PQ_MDS_PIB 1" >>$(obj)include/config.h ; \
+	fi ; \
+	if [ "$(findstring _ATM_,$@)" ] ; then \
+		echo -n "...ATM..." ; \
+		echo "#define CONFIG_PQ_MDS_PIB 1" >>$(obj)include/config.h ; \
+		echo "#define CONFIG_PQ_MDS_PIB_ATM     1" >>$(obj)include/config.h ; \
 	fi ;
 	@$(MKCONFIG) -a MPC832XEMDS ppc mpc83xx mpc832xemds freescale
 
@@ -1808,7 +1816,8 @@ MPC8349ITXGP_config:	unconfig
 MPC8360EMDS_config \
 MPC8360EMDS_HOST_33_config \
 MPC8360EMDS_HOST_66_config \
-MPC8360EMDS_SLAVE_config:	unconfig
+MPC8360EMDS_SLAVE_config \
+MPC8360EMDS_ATM_config: unconfig
 	@mkdir -p $(obj)include
 	@echo "" >$(obj)include/config.h ; \
 	if [ "$(findstring _HOST_,$@)" ] ; then \
@@ -1823,10 +1832,17 @@ MPC8360EMDS_SLAVE_config:	unconfig
 	if [ "$(findstring _33_,$@)" ] ; then \
 		echo -n "...33M ..." ; \
 		echo "#define PCI_33M" >>$(obj)include/config.h ; \
+		echo "#define CONFIG_PQ_MDS_PIB 1" >>$(obj)include/config.h ; \
 	fi ; \
 	if [ "$(findstring _66_,$@)" ] ; then \
 		echo -n "...66M..." ; \
 		echo "#define PCI_66M" >>$(obj)include/config.h ; \
+		echo "#define CONFIG_PQ_MDS_PIB 1" >>$(obj)include/config.h ; \
+	fi ; \
+	if [ "$(findstring _ATM_,$@)" ] ; then \
+		echo -n "...ATM..." ; \
+		echo "#define CONFIG_PQ_MDS_PIB 1" >>$(obj)include/config.h ; \
+		echo "#define CONFIG_PQ_MDS_PIB_ATM     1" >>$(obj)include/config.h ; \
 	fi ;
 	@$(MKCONFIG) -a MPC8360EMDS ppc mpc83xx mpc8360emds freescale
 
@@ -1985,13 +2001,13 @@ AmigaOneG3SE_config:	unconfig
 BAB7xx_config: unconfig
 	@$(MKCONFIG) $(@:_config=) ppc 74xx_7xx bab7xx eltec
 
-CPCI750_config:        unconfig
+CPCI750_config:	unconfig
 	@$(MKCONFIG) CPCI750 ppc 74xx_7xx cpci750 esd
 
-DB64360_config:  unconfig
+DB64360_config:	unconfig
 	@$(MKCONFIG) DB64360 ppc 74xx_7xx db64360 Marvell
 
-DB64460_config:  unconfig
+DB64460_config:	unconfig
 	@$(MKCONFIG) DB64460 ppc 74xx_7xx db64460 Marvell
 
 ELPPC_config: unconfig
@@ -2587,7 +2603,16 @@ bf561-ezkit_config:	unconfig
 #########################################################################
 
 atstk1002_config	:	unconfig
-	@$(MKCONFIG) $(@:_config=) avr32 at32ap atstk1000 atmel at32ap7000
+	@$(MKCONFIG) $(@:_config=) avr32 at32ap atstk1000 atmel at32ap700x
+
+atstk1003_config	:	unconfig
+	@$(MKCONFIG) $(@:_config=) avr32 at32ap atstk1000 atmel at32ap700x
+
+atstk1004_config	:	unconfig
+	@$(MKCONFIG) $(@:_config=) avr32 at32ap atstk1000 atmel at32ap700x
+
+atngw100_config	:	unconfig
+	@./mkconfig $(@:_config=) avr32 at32ap atngw100 atmel at32ap700x
 
 #########################################################################
 #########################################################################
diff --git a/README b/README
index 09eb76f..0c2b020 100644
--- a/README
+++ b/README
@@ -235,9 +235,7 @@ The following options need to be configured:
 - Board Type:	Define exactly one, e.g. CONFIG_MPC8540ADS.
 
 - CPU Daughterboard Type: (if CONFIG_ATSTK1000 is defined)
-		Define exactly one of
-		CONFIG_ATSTK1002
-
+		Define exactly one, e.g. CONFIG_ATSTK1002
 
 - CPU Module Type: (if CONFIG_COGENT is defined)
 		Define exactly one of
diff --git a/board/amcc/sequoia/cmd_sequoia.c b/board/amcc/sequoia/cmd_sequoia.c
index f3803c0..6b9043a 100644
--- a/board/amcc/sequoia/cmd_sequoia.c
+++ b/board/amcc/sequoia/cmd_sequoia.c
@@ -25,6 +25,7 @@
 #include <common.h>
 #include <command.h>
 #include <i2c.h>
+#include <asm/io.h>
 
 /*
  * There are 2 versions of production Sequoia & Rainier platforms.
@@ -39,7 +40,7 @@
  * All Sequoias & Rainiers select from two possible EEPROMs in Boot
  * Config F. One for 33MHz PCI, one for 66MHz PCI. The following
  * values are for the 33MHz PCI configuration. Byte 5 (0 base) is
- * the only  value affected for a 66MHz PCI and simply needs a +0x10.
+ * the only value affected for a 33MHz PCI and simply needs a | 0x08.
  */
 
 #define NAND_COMPATIBLE	0x01
@@ -56,6 +57,7 @@ static char *config_labels[] = {
 	"CPU: 416 PLB: 166 OPB: 83 EBC: 55",
 	"CPU: 500 PLB: 166 OPB: 83 EBC: 55",
 	"CPU: 533 PLB: 133 OPB: 66 EBC: 66",
+	"CPU: 667 PLB: 133 OPB: 66 EBC: 66",
 	"CPU: 667 PLB: 166 OPB: 83 EBC: 55",
 	NULL
 };
@@ -97,6 +99,11 @@ static u8 boot_configs[][17] = {
 		0x08, 0x23, 0x50, 0x0d, 0x05, 0x00, 0x00
 	},
 	{
+		(NOR_COMPATIBLE),
+		0x87, 0x78, 0xa2, 0x56, 0x09, 0x57, 0xa0, 0x30, 0x40,
+		0x08, 0x23, 0x50, 0x0d, 0x05, 0x00, 0x00
+	},
+	{
 		(NAND_COMPATIBLE | NOR_COMPATIBLE),
 		0x87, 0x78, 0xa2, 0x52, 0x09, 0xd7, 0xa0, 0x30, 0x40,
 		0x08, 0x23, 0x50, 0x0d, 0x05, 0x00, 0x00
@@ -200,8 +207,12 @@ static int do_bootstrap(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 	}
 
 	/* check CPLD register +5 for PCI 66MHz flag */
-	if (in8(CFG_BCSR_BASE + 5) & 0x01)
-		buf[5] += 0x10;
+	if ((in_8((void *)(CFG_BCSR_BASE + 5)) & CFG_BCSR5_PCI66EN) == 0)
+		/*
+		 * PLB-to-PCI divisor = 3 for 33MHz sync PCI
+		 * instead of 2 for 66MHz systems
+		 */
+		buf[5] |= 0x08;
 
 	if (i2c_write(I2C_EEPROM_ADDR, 0, 1, buf, 16) != 0)
 		printf("Error writing to EEPROM at address 0x%x\n", I2C_EEPROM_ADDR);
diff --git a/board/amcc/sequoia/sequoia.c b/board/amcc/sequoia/sequoia.c
index f823117..4e47ab3 100644
--- a/board/amcc/sequoia/sequoia.c
+++ b/board/amcc/sequoia/sequoia.c
@@ -1,5 +1,5 @@
 /*
- * (C) Copyright 2006
+ * (C) Copyright 2006-2007
  * Stefan Roese, DENX Software Engineering, sr@denx.de.
  *
  * (C) Copyright 2006
@@ -24,6 +24,7 @@
 
 #include <common.h>
 #include <asm/processor.h>
+#include <asm/io.h>
 #include <ppc440.h>
 
 DECLARE_GLOBAL_DATA_PTR;
@@ -362,8 +363,8 @@ int checkboard(void)
 	printf("Board: Rainier - AMCC PPC440GRx Evaluation Board");
 #endif
 
-	rev = in8(CFG_BCSR_BASE + 0);
-	val = in8(CFG_BCSR_BASE + 5) & 0x01;
+	rev = in_8((void *)(CFG_BCSR_BASE + 0));
+	val = in_8((void *)(CFG_BCSR_BASE + 5)) & CFG_BCSR5_PCI66EN;
 	printf(", Rev. %X, PCI=%d MHz", rev, val ? 66 : 33);
 
 	if (s != NULL) {
diff --git a/board/amcc/yosemite/yosemite.c b/board/amcc/yosemite/yosemite.c
index 912f09e..6ec922a 100644
--- a/board/amcc/yosemite/yosemite.c
+++ b/board/amcc/yosemite/yosemite.c
@@ -1,4 +1,6 @@
 /*
+ * (C) Copyright 2006-2007
+ * Stefan Roese, DENX Software Engineering, sr@denx.de.
  *
  * See file CREDITS for list of people who contributed to this
  * project.
@@ -22,6 +24,7 @@
 #include <common.h>
 #include <ppc4xx.h>
 #include <asm/processor.h>
+#include <asm/io.h>
 #include <spd_sdram.h>
 
 DECLARE_GLOBAL_DATA_PTR;
@@ -181,8 +184,8 @@ int checkboard(void)
 	printf("Board: Yellowstone - AMCC PPC440GR Evaluation Board");
 #endif
 
-	rev = *(u8 *)(CFG_CPLD + 0);
-	val = *(u8 *)(CFG_CPLD + 5) & 0x01;
+	rev = in_8((void *)(CFG_BCSR_BASE + 0));
+	val = in_8((void *)(CFG_BCSR_BASE + 5)) & CFG_BCSR5_PCI66EN;
 	printf(", Rev. %X, PCI=%d MHz", rev, val ? 66 : 33);
 
 	if (s != NULL) {
diff --git a/board/atmel/atngw100/Makefile b/board/atmel/atngw100/Makefile
new file mode 100644
index 0000000..f1ea6e6
--- /dev/null
+++ b/board/atmel/atngw100/Makefile
@@ -0,0 +1,40 @@
+#
+# Copyright (C) 2005-2006 Atmel Corporation
+#
+# See file CREDITS for list of people who contributed to this project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+
+include $(TOPDIR)/config.mk
+
+LIB	:= $(obj)lib$(BOARD).a
+
+COBJS	:= $(BOARD).o flash.o eth.o
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(SOBJS) $(COBJS))
+
+$(LIB): $(obj).depend $(OBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS)
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/board/atmel/atngw100/atngw100.c b/board/atmel/atngw100/atngw100.c
new file mode 100644
index 0000000..bd4b6b4
--- /dev/null
+++ b/board/atmel/atngw100/atngw100.c
@@ -0,0 +1,73 @@
+/*
+ * Copyright (C) 2006 Atmel Corporation
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#include <common.h>
+
+#include <asm/io.h>
+#include <asm/sdram.h>
+#include <asm/arch/gpio.h>
+#include <asm/arch/hmatrix2.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+static const struct sdram_info sdram = {
+	.phys_addr	= CFG_SDRAM_BASE,
+	.row_bits	= 13,
+	.col_bits	= 9,
+	.bank_bits	= 2,
+	.cas		= 3,
+	.twr		= 2,
+	.trc		= 7,
+	.trp		= 2,
+	.trcd		= 2,
+	.tras		= 5,
+	.txsr		= 5,
+};
+
+int board_early_init_f(void)
+{
+	/* Set the SDRAM_ENABLE bit in the HEBI SFR */
+	hmatrix2_writel(SFR4, 1 << 1);
+
+	gpio_enable_ebi();
+	gpio_enable_usart1();
+
+#if defined(CONFIG_MACB)
+	gpio_enable_macb0();
+	gpio_enable_macb1();
+#endif
+#if defined(CONFIG_MMC)
+	gpio_enable_mmci();
+#endif
+
+	return 0;
+}
+
+long int initdram(int board_type)
+{
+	return sdram_init(&sdram);
+}
+
+void board_init_info(void)
+{
+	gd->bd->bi_phy_id[0] = 0x01;
+	gd->bd->bi_phy_id[1] = 0x03;
+}
diff --git a/board/atmel/atngw100/config.mk b/board/atmel/atngw100/config.mk
new file mode 100644
index 0000000..9a794e5
--- /dev/null
+++ b/board/atmel/atngw100/config.mk
@@ -0,0 +1,3 @@
+TEXT_BASE		= 0x00000000
+PLATFORM_RELFLAGS	+= -ffunction-sections -fdata-sections
+PLATFORM_LDFLAGS	+= --gc-sections
diff --git a/board/atmel/atngw100/eth.c b/board/atmel/atngw100/eth.c
new file mode 100644
index 0000000..d1d57bb
--- /dev/null
+++ b/board/atmel/atngw100/eth.c
@@ -0,0 +1,36 @@
+/*
+ * Copyright (C) 2006 Atmel Corporation
+ *
+ * Ethernet initialization for the AVR32 Network Gateway
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#include <common.h>
+
+#include <asm/arch/memory-map.h>
+
+extern int macb_eth_initialize(int id, void *regs, unsigned int phy_addr);
+
+#ifdef CONFIG_CMD_NET
+void atngw100_eth_initialize(bd_t *bi)
+{
+	macb_eth_initialize(0, (void *)MACB0_BASE, bi->bi_phy_id[0]);
+	macb_eth_initialize(1, (void *)MACB1_BASE, bi->bi_phy_id[1]);
+}
+#endif
diff --git a/board/atmel/atngw100/flash.c b/board/atmel/atngw100/flash.c
new file mode 100644
index 0000000..ea3a62e
--- /dev/null
+++ b/board/atmel/atngw100/flash.c
@@ -0,0 +1,236 @@
+/*
+ * Copyright (C) 2006 Atmel Corporation
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#include <common.h>
+
+#ifdef CONFIG_ATNGW100_EXT_FLASH
+#include <asm/cacheflush.h>
+#include <asm/io.h>
+#include <asm/sections.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+flash_info_t flash_info[1];
+
+static void __flashprog flash_identify(uint16_t *flash, flash_info_t *info)
+{
+	unsigned long flags;
+
+	flags = disable_interrupts();
+
+	dcache_flush_unlocked();
+
+	writew(0xaa, flash + 0x555);
+	writew(0x55, flash + 0xaaa);
+	writew(0x90, flash + 0x555);
+	info->flash_id = readl(flash);
+	writew(0xff, flash);
+
+	readw(flash);
+
+	if (flags)
+		enable_interrupts();
+}
+
+unsigned long flash_init(void)
+{
+	unsigned long addr;
+	unsigned int i;
+
+	gd->bd->bi_flashstart = CFG_FLASH_BASE;
+	gd->bd->bi_flashsize = CFG_FLASH_SIZE;
+	gd->bd->bi_flashoffset = _edata - _text;
+
+	flash_info[0].size = CFG_FLASH_SIZE;
+	flash_info[0].sector_count = 135;
+
+	flash_identify(uncached((void *)CFG_FLASH_BASE), &flash_info[0]);
+
+	for (i = 0, addr = 0; i < 8; i++, addr += 0x2000)
+		flash_info[0].start[i] = addr;
+	for (; i < flash_info[0].sector_count; i++, addr += 0x10000)
+		flash_info[0].start[i] = addr;
+
+	return CFG_FLASH_SIZE;
+}
+
+void flash_print_info(flash_info_t *info)
+{
+	printf("Flash: Vendor ID: 0x%02x, Product ID: 0x%02x\n",
+	       info->flash_id >> 16, info->flash_id & 0xffff);
+	printf("Size: %ld MB in %d sectors\n",
+	       info->size >> 10, info->sector_count);
+}
+
+int __flashprog flash_erase(flash_info_t *info, int s_first, int s_last)
+{
+	unsigned long flags;
+	unsigned long start_time;
+	uint16_t *fb, *sb;
+	unsigned int i;
+	int ret;
+	uint16_t status;
+
+	if ((s_first < 0) || (s_first > s_last)
+	    || (s_last >= info->sector_count)) {
+		puts("Error: first and/or last sector out of range\n");
+		return ERR_INVAL;
+	}
+
+	for (i = s_first; i < s_last; i++)
+		if (info->protect[i]) {
+			printf("Error: sector %d is protected\n", i);
+			return ERR_PROTECTED;
+		}
+
+	fb = (uint16_t *)uncached(info->start[0]);
+
+	dcache_flush_unlocked();
+
+	for (i = s_first; (i <= s_last) && !ctrlc(); i++) {
+		printf("Erasing sector %3d...", i);
+
+		sb = (uint16_t *)uncached(info->start[i]);
+
+		flags = disable_interrupts();
+
+		start_time = get_timer(0);
+
+		/* Unlock sector */
+		writew(0xaa, fb + 0x555);
+		writew(0x70, sb);
+
+		/* Erase sector */
+		writew(0xaa, fb + 0x555);
+		writew(0x55, fb + 0xaaa);
+		writew(0x80, fb + 0x555);
+		writew(0xaa, fb + 0x555);
+		writew(0x55, fb + 0xaaa);
+		writew(0x30, sb);
+
+		/* Wait for completion */
+		ret = ERR_OK;
+		do {
+			/* TODO: Timeout */
+			status = readw(sb);
+		} while ((status != 0xffff) && !(status & 0x28));
+
+		writew(0xf0, fb);
+
+		/*
+		 * Make sure the command actually makes it to the bus
+		 * before we re-enable interrupts.
+		 */
+		readw(fb);
+
+		if (flags)
+			enable_interrupts();
+
+		if (status != 0xffff) {
+			printf("Flash erase error at address 0x%p: 0x%02x\n",
+			       sb, status);
+			ret = ERR_PROG_ERROR;
+			break;
+		}
+	}
+
+	if (ctrlc())
+		printf("User interrupt!\n");
+
+	return ERR_OK;
+}
+
+int __flashprog write_buff(flash_info_t *info, uchar *src,
+			   ulong addr, ulong count)
+{
+	unsigned long flags;
+	uint16_t *base, *p, *s, *end;
+	uint16_t word, status, status1;
+	int ret = ERR_OK;
+
+	if (addr < info->start[0]
+	    || (addr + count) > (info->start[0] + info->size)
+	    || (addr + count) < addr) {
+		puts("Error: invalid address range\n");
+		return ERR_INVAL;
+	}
+
+	if (addr & 1 || count & 1 || (unsigned int)src & 1) {
+		puts("Error: misaligned source, destination or count\n");
+		return ERR_ALIGN;
+	}
+
+	base = (uint16_t *)uncached(info->start[0]);
+	end = (uint16_t *)uncached(addr + count);
+
+	flags = disable_interrupts();
+
+	dcache_flush_unlocked();
+	sync_write_buffer();
+
+	for (p = (uint16_t *)uncached(addr), s = (uint16_t *)src;
+	     p < end && !ctrlc(); p++, s++) {
+		word = *s;
+
+		writew(0xaa, base + 0x555);
+		writew(0x55, base + 0xaaa);
+		writew(0xa0, base + 0x555);
+		writew(word, p);
+
+		sync_write_buffer();
+
+		/* Wait for completion */
+		status1 = readw(p);
+		do {
+			/* TODO: Timeout */
+			status = status1;
+			status1 = readw(p);
+		} while (((status ^ status1) & 0x40)	/* toggled */
+			 && !(status1 & 0x28));		/* error bits */
+
+		/*
+		 * We'll need to check once again for toggle bit
+		 * because the toggle bit may stop toggling as I/O5
+		 * changes to "1" (ref at49bv642.pdf p9)
+		 */
+		status1 = readw(p);
+		status = readw(p);
+		if ((status ^ status1) & 0x40) {
+			printf("Flash write error at address 0x%p: "
+			       "0x%02x != 0x%02x\n",
+			       p, status,word);
+			ret = ERR_PROG_ERROR;
+			writew(0xf0, base);
+			readw(base);
+			break;
+		}
+
+		writew(0xf0, base);
+		readw(base);
+	}
+
+	if (flags)
+		enable_interrupts();
+
+	return ret;
+}
+
+#endif /* CONFIG_ATSTK1000_EXT_FLASH */
diff --git a/board/atmel/atngw100/u-boot.lds b/board/atmel/atngw100/u-boot.lds
new file mode 100644
index 0000000..34e347a
--- /dev/null
+++ b/board/atmel/atngw100/u-boot.lds
@@ -0,0 +1,80 @@
+/* -*- Fundamental -*-
+ *
+ * Copyright (C) 2005-2006 Atmel Corporation
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+OUTPUT_FORMAT("elf32-avr32", "elf32-avr32", "elf32-avr32")
+OUTPUT_ARCH(avr32)
+ENTRY(_start)
+
+SECTIONS
+{
+	. = 0;
+	_text = .;
+	.text : {
+		*(.text)
+		*(.text.*)
+	}
+
+	. = ALIGN(32);
+	__flashprog_start = .;
+	.flashprog : {
+		*(.flashprog)
+	}
+	. = ALIGN(32);
+	__flashprog_end = .;
+	_etext = .;
+
+	.rodata : {
+		*(.rodata)
+		*(.rodata.*)
+	}
+
+	. = ALIGN(8);
+	_data = .;
+	.data : {
+		*(.data)
+		*(.data.*)
+	}
+
+	. = ALIGN(4);
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : {
+		KEEP(*(.u_boot_cmd))
+	}
+	__u_boot_cmd_end = .;
+
+	. = ALIGN(4);
+	_got = .;
+	.got : {
+		*(.got)
+	}
+	_egot = .;
+
+	. = ALIGN(8);
+	_edata = .;
+
+	.bss : {
+		*(.bss)
+		*(.bss.*)
+	}
+	. = ALIGN(8);
+	_end = .;
+}
diff --git a/board/freescale/common/pq-mds-pib.c b/board/freescale/common/pq-mds-pib.c
index d79f2eb..e4f96e8 100644
--- a/board/freescale/common/pq-mds-pib.c
+++ b/board/freescale/common/pq-mds-pib.c
@@ -79,19 +79,19 @@ int pib_init(void)
 
 	printf("QOC3 ATM card on PMC0\n");
 #elif defined(CONFIG_MPC832XEMDS)
-	val = 0;
-	i2c_write(0x26, 0x7, 1, &val, 1);
-	val = 0xf7;
-	i2c_write(0x26, 0x3, 1, &val, 1);
-
-	val = 0;
-	i2c_write(0x21, 0x6, 1, &val, 1);
-	i2c_write(0x21, 0x7, 1, &val, 1);
-
-	val = 0xdf;
-	i2c_write(0x21, 0x2, 1, &val, 1);
-	val = 0xef;
-	i2c_write(0x21, 0x3, 1, &val, 1);
+	val8 = 0;
+	i2c_write(0x26, 0x7, 1, &val8, 1);
+	val8 = 0xf7;
+	i2c_write(0x26, 0x3, 1, &val8, 1);
+
+	val8 = 0;
+	i2c_write(0x21, 0x6, 1, &val8, 1);
+	i2c_write(0x21, 0x7, 1, &val8, 1);
+
+	val8 = 0xdf;
+	i2c_write(0x21, 0x2, 1, &val8, 1);
+	val8 = 0xef;
+	i2c_write(0x21, 0x3, 1, &val8, 1);
 
 	eieio();
 
diff --git a/board/innokom/innokom.c b/board/innokom/innokom.c
index 7f8f47c..c2b88ae 100644
--- a/board/innokom/innokom.c
+++ b/board/innokom/innokom.c
@@ -72,7 +72,7 @@ int i2c_init_board(void)
 
 int misc_init_r(void)
 {
-	uchar *str;
+	char *str;
 
 	/* determine if the software update key is pressed during startup   */
 	if (GPLR0 & 0x00000800) {
diff --git a/board/motionpro/motionpro.c b/board/motionpro/motionpro.c
index f83998e..68257b8 100644
--- a/board/motionpro/motionpro.c
+++ b/board/motionpro/motionpro.c
@@ -138,6 +138,12 @@ long int initdram(int board_type)
 #ifndef CFG_RAMBOOT
 	ulong test1, test2;
 
+	/* According to AN3221 (MPC5200B SDRAM Initialization and
+	 * Configuration), the SDelay register must be written a value of
+	 * 0x00000004 as the first step of the SDRAM contorller configuration.
+	 */
+	*(vu_long *)MPC5XXX_SDRAM_SDELAY = 0x04;
+
 	/* configure SDRAM start/end for detection */
 	*(vu_long *)MPC5XXX_SDRAM_CS0CFG = 0x0000001e; /* 2G at 0x0 */
 	*(vu_long *)MPC5XXX_SDRAM_CS1CFG = 0x80000000; /* disabled */
diff --git a/board/pxa255_idp/Makefile b/board/pxa255_idp/Makefile
index a957dd3..32399f0 100644
--- a/board/pxa255_idp/Makefile
+++ b/board/pxa255_idp/Makefile
@@ -27,7 +27,7 @@ include $(TOPDIR)/config.mk
 LIB	= $(obj)lib$(BOARD).a
 
 COBJS	:= pxa_idp.o
-SOBJS	:= memsetup.o
+SOBJS	:= lowlevel_init.o
 
 SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
 OBJS	:= $(addprefix $(obj),$(COBJS))
diff --git a/board/pxa255_idp/config.mk b/board/pxa255_idp/config.mk
index d2a2040..55c8b27 100644
--- a/board/pxa255_idp/config.mk
+++ b/board/pxa255_idp/config.mk
@@ -1,3 +1,3 @@
 #TEXT_BASE = 0xa1700000
-TEXT_BASE = 0xa3000000
+TEXT_BASE = 0xa3080000
 #TEXT_BASE = 0
diff --git a/board/pxa255_idp/lowlevel_init.S b/board/pxa255_idp/lowlevel_init.S
new file mode 100644
index 0000000..aaa4d8e
--- /dev/null
+++ b/board/pxa255_idp/lowlevel_init.S
@@ -0,0 +1,496 @@
+/*
+ * Most of this taken from Redboot hal_platform_setup.h with cleanup
+ *
+ * NOTE: I haven't clean this up considerably, just enough to get it
+ * running. See hal_platform_setup.h for the source. See
+ * board/cradle/lowlevel_init.S for another PXA250 setup that is
+ * much cleaner.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include <version.h>
+#include <asm/arch/pxa-regs.h>
+
+DRAM_SIZE:  .long   CFG_DRAM_SIZE
+
+/* wait for coprocessor write complete */
+	.macro CPWAIT reg
+	mrc  p15,0,\reg,c2,c0,0
+	mov  \reg,\reg
+	sub  pc,pc,#4
+	.endm
+
+/*
+ * 	Memory setup
+ */
+.globl lowlevel_init
+lowlevel_init:
+
+	mov      r10, lr
+
+#ifdef DEBUG_BLINK_ENABLE
+	/* 3rd blink */
+	bl	blink
+#endif
+
+	/* Set up GPIO pins first ----------------------------------------- */
+	ldr		r0,	=GPSR0
+	ldr		r1,	=CFG_GPSR0_VAL
+	str		r1,   [r0]
+
+	ldr		r0,	=GPSR1
+	ldr		r1,	=CFG_GPSR1_VAL
+	str		r1,   [r0]
+
+	ldr		r0,	=GPSR2
+	ldr		r1,	=CFG_GPSR2_VAL
+	str		r1,   [r0]
+
+	ldr		r0,	=GPCR0
+	ldr		r1,	=CFG_GPCR0_VAL
+	str		r1,   [r0]
+
+	ldr		r0,	=GPCR1
+	ldr		r1,	=CFG_GPCR1_VAL
+	str		r1,   [r0]
+
+	ldr		r0,	=GPCR2
+	ldr		r1,	=CFG_GPCR2_VAL
+	str		r1,   [r0]
+
+	ldr		r0,	=GPDR0
+	ldr		r1,	=CFG_GPDR0_VAL
+	str		r1,   [r0]
+
+	ldr		r0,	=GPDR1
+	ldr		r1,	=CFG_GPDR1_VAL
+	str		r1,   [r0]
+
+	ldr		r0,	=GPDR2
+	ldr		r1,	=CFG_GPDR2_VAL
+	str		r1,   [r0]
+
+	ldr		r0,	=GAFR0_L
+	ldr		r1,	=CFG_GAFR0_L_VAL
+	str		r1,   [r0]
+
+	ldr		r0,	=GAFR0_U
+	ldr		r1,	=CFG_GAFR0_U_VAL
+	str		r1,   [r0]
+
+	ldr		r0,	=GAFR1_L
+	ldr		r1,	=CFG_GAFR1_L_VAL
+	str		r1,   [r0]
+
+	ldr		r0,	=GAFR1_U
+	ldr		r1,	=CFG_GAFR1_U_VAL
+	str		r1,   [r0]
+
+	ldr		r0,	=GAFR2_L
+	ldr		r1,	=CFG_GAFR2_L_VAL
+	str		r1,   [r0]
+
+	ldr		r0,	=GAFR2_U
+	ldr		r1,	=CFG_GAFR2_U_VAL
+	str		r1,   [r0]
+
+	ldr	r0,	=PSSR		/* enable GPIO pins */
+	ldr		r1,	=CFG_PSSR_VAL
+	str		r1,   [r0]
+
+#ifdef DEBUG_BLINK_ENABLE
+	/* 4th debug blink */
+	bl 	blink
+#endif
+
+	/* ---------------------------------------------------------------- */
+	/* Enable memory interface                                          */
+	/*                                                                  */
+	/* The sequence below is based on the recommended init steps        */
+	/* detailed in the Intel PXA250 Operating Systems Developers Guide, */
+	/* Chapter 10.                                                      */
+	/* ---------------------------------------------------------------- */
+
+	/* ---------------------------------------------------------------- */
+	/* Step 1: Wait for at least 200 microsedonds to allow internal     */
+	/*         clocks to settle. Only necessary after hard reset...     */
+	/*         FIXME: can be optimized later                            */
+	/* ---------------------------------------------------------------- */
+
+	ldr r3, =OSCR			/* reset the OS Timer Count to zero */
+	mov r2, #0
+	str r2, [r3]
+	ldr r4, =0x300			/* really 0x2E1 is about 200usec,   */
+					/* so 0x300 should be plenty        */
+1:
+	ldr r2, [r3]
+	cmp r4, r2
+	bgt 1b
+
+mem_init:
+
+	ldr     r1,  =MEMC_BASE		/* get memory controller base addr. */
+
+	/* ---------------------------------------------------------------- */
+	/* Step 2a: Initialize Asynchronous static memory controller        */
+	/* ---------------------------------------------------------------- */
+
+	/* MSC registers: timing, bus width, mem type                       */
+
+	/* MSC0: nCS(0,1)                                                   */
+	ldr     r2,   =CFG_MSC0_VAL
+	str     r2,   [r1, #MSC0_OFFSET]
+	ldr     r2,   [r1, #MSC0_OFFSET]	/* read back to ensure      */
+						/* that data latches        */
+	/* MSC1: nCS(2,3)                                                   */
+	ldr     r2,  =CFG_MSC1_VAL
+	str     r2,  [r1, #MSC1_OFFSET]
+	ldr     r2,  [r1, #MSC1_OFFSET]
+
+	/* MSC2: nCS(4,5)                                                   */
+	ldr     r2,  =CFG_MSC2_VAL
+	str     r2,  [r1, #MSC2_OFFSET]
+	ldr     r2,  [r1, #MSC2_OFFSET]
+
+	/* ---------------------------------------------------------------- */
+	/* Step 2b: Initialize Card Interface                               */
+	/* ---------------------------------------------------------------- */
+
+	/* MECR: Memory Expansion Card Register                             */
+	ldr     r2,  =CFG_MECR_VAL
+	str     r2,  [r1, #MECR_OFFSET]
+	ldr	r2,	[r1, #MECR_OFFSET]
+
+	/* MCMEM0: Card Interface slot 0 timing                             */
+	ldr     r2,  =CFG_MCMEM0_VAL
+	str     r2,  [r1, #MCMEM0_OFFSET]
+	ldr	r2,	[r1, #MCMEM0_OFFSET]
+
+	/* MCMEM1: Card Interface slot 1 timing                             */
+	ldr     r2,  =CFG_MCMEM1_VAL
+	str     r2,  [r1, #MCMEM1_OFFSET]
+	ldr	r2,	[r1, #MCMEM1_OFFSET]
+
+	/* MCATT0: Card Interface Attribute Space Timing, slot 0            */
+	ldr     r2,  =CFG_MCATT0_VAL
+	str     r2,  [r1, #MCATT0_OFFSET]
+	ldr	r2,	[r1, #MCATT0_OFFSET]
+
+	/* MCATT1: Card Interface Attribute Space Timing, slot 1            */
+	ldr     r2,  =CFG_MCATT1_VAL
+	str     r2,  [r1, #MCATT1_OFFSET]
+	ldr	r2,	[r1, #MCATT1_OFFSET]
+
+	/* MCIO0: Card Interface I/O Space Timing, slot 0                   */
+	ldr     r2,  =CFG_MCIO0_VAL
+	str     r2,  [r1, #MCIO0_OFFSET]
+	ldr	r2,	[r1, #MCIO0_OFFSET]
+
+	/* MCIO1: Card Interface I/O Space Timing, slot 1                   */
+	ldr     r2,  =CFG_MCIO1_VAL
+	str     r2,  [r1, #MCIO1_OFFSET]
+	ldr	r2,	[r1, #MCIO1_OFFSET]
+
+#ifdef DEBUG_BLINK_ENABLE
+	/* 5th blink */
+	bl 	blink
+#endif
+
+	/* ---------------------------------------------------------------- */
+	/* Step 2c: Write FLYCNFG  FIXME: what's that???                    */
+	/* ---------------------------------------------------------------- */
+
+	/* ---------------------------------------------------------------- */
+	/* Step 2d: Initialize Timing for Sync Memory (SDCLK0)              */
+	/* ---------------------------------------------------------------- */
+
+	/* Before accessing MDREFR we need a valid DRI field, so we set     */
+	/* this to power on defaults + DRI field.                           */
+
+	ldr     r3,     =CFG_MDREFR_VAL
+	ldr     r2,     =0xFFF
+	and     r3,     r3,  r2
+	ldr	r4,	=0x03ca4000
+	orr     r4,     r4,  r3
+	str	r4,	[r1, #MDREFR_OFFSET]	/* write back MDREFR        */
+	ldr     r4,  [r1, #MDREFR_OFFSET]
+
+	/* Note: preserve the mdrefr value in r4                            */
+
+	/* ---------------------------------------------------------------- */
+	/* Step 3: Initialize Synchronous Static Memory (Flash/Peripherals) */
+	/* ---------------------------------------------------------------- */
+
+	/* Initialize SXCNFG register. Assert the enable bits               */
+
+	/* Write SXMRS to cause an MRS command to all enabled banks of      */
+	/* synchronous static memory. Note that SXLCR need not be written   */
+	/* at this time.                                                    */
+
+	/* FIXME: we use async mode for now                                 */
+
+	/* ---------------------------------------------------------------- */
+	/* Step 4: Initialize SDRAM                                         */
+	/* ---------------------------------------------------------------- */
+
+	/* set MDREFR according to user define with exception of a few bits */
+
+	ldr     r4,     =CFG_MDREFR_VAL
+	orr	r4,	r4,	#(MDREFR_SLFRSH)
+	bic	r4,	r4,	#(MDREFR_E1PIN|MDREFR_E0PIN)
+	str     r4,     [r1, #MDREFR_OFFSET]    /* write back MDREFR        */
+	ldr     r4,  [r1, #MDREFR_OFFSET]
+
+	/* Step 4b: de-assert MDREFR:SLFRSH.                                */
+
+	bic	r4,	r4,	#(MDREFR_SLFRSH)
+	str     r4,     [r1, #MDREFR_OFFSET]    /* write back MDREFR        */
+	ldr     r4,  [r1, #MDREFR_OFFSET]
+
+	/* Step 4c: assert MDREFR:E1PIN and E0PIO as desired                */
+
+	ldr     r4,     =CFG_MDREFR_VAL
+	str     r4,     [r1, #MDREFR_OFFSET]    /* write back MDREFR        */
+	ldr     r4,     [r1, #MDREFR_OFFSET]
+
+
+	/* Step 4d: write MDCNFG with MDCNFG:DEx deasserted (set to 0), to  */
+	/*          configure but not enable each SDRAM partition pair.     */
+
+	ldr	r4,	=CFG_MDCNFG_VAL
+	bic	r4,	r4,	#(MDCNFG_DE0|MDCNFG_DE1)
+
+	str     r4,     [r1, #MDCNFG_OFFSET]	/* write back MDCNFG        */
+	ldr     r4,     [r1, #MDCNFG_OFFSET]
+
+	/* Step 4e: Wait for the clock to the SDRAMs to stabilize,          */
+	/*          100..200 sec.                                          */
+
+	ldr r3, =OSCR			/* reset the OS Timer Count to zero */
+	mov r2, #0
+	    str r2, [r3]
+	ldr r4, =0x300			/* really 0x2E1 is about 200usec,   */
+					/* so 0x300 should be plenty        */
+1:
+	    ldr r2, [r3]
+	    cmp r4, r2
+	    bgt 1b
+
+	/* Step 4f: Trigger a number (usually 8) refresh cycles by          */
+	/*          attempting non-burst read or write accesses to disabled */
+	/*          SDRAM, as commonly specified in the power up sequence   */
+	/*          documented in SDRAM data sheets. The address(es) used   */
+	/*          for this purpose must not be cacheable.                 */
+
+	ldr	r3,	=CFG_DRAM_BASE
+	str	r2,	[r3]
+	str	r2,	[r3]
+	str	r2,	[r3]
+	str	r2,	[r3]
+	str	r2,	[r3]
+	str	r2,	[r3]
+	str	r2,	[r3]
+	str	r2,	[r3]
+
+	/* Step 4g: Write MDCNFG with enable bits asserted                  */
+	/*          (MDCNFG:DEx set to 1).                                  */
+
+	ldr     r3,  [r1, #MDCNFG_OFFSET]
+	orr	r3,	r3,	#(MDCNFG_DE0|MDCNFG_DE1)
+	str     r3,  [r1, #MDCNFG_OFFSET]
+
+	/* Step 4h: Write MDMRS.                                            */
+
+	ldr     r2,  =CFG_MDMRS_VAL
+	str     r2,  [r1, #MDMRS_OFFSET]
+
+	/* We are finished with Intel's memory controller initialisation    */
+#if 0
+	/* FIXME turn on serial ports */
+	/* look into moving this to board_init() */
+	ldr 	r2, =(PXA_CS5_PHYS + 0x03C0002c)
+	mov	r3, #0x13
+	str	r3, [r2]
+#endif
+
+#ifdef DEBUG_BLINK_ENABLE
+	/* 6th blink */
+	bl 	blink
+#endif
+
+	/* ---------------------------------------------------------------- */
+	/* Disable (mask) all interrupts at interrupt controller            */
+	/* ---------------------------------------------------------------- */
+
+initirqs:
+
+	mov     r1, #0		/* clear int. level register (IRQ, not FIQ) */
+	ldr     r2,  =ICLR
+	str     r1,  [r2]
+
+	ldr     r2,  =ICMR	/* mask all interrupts at the controller    */
+	str     r1,  [r2]
+
+	/* ---------------------------------------------------------------- */
+	/* Clock initialisation                                             */
+	/* ---------------------------------------------------------------- */
+
+initclks:
+
+	/* Disable the peripheral clocks, and set the core clock frequency  */
+	/* (hard-coding at 398.12MHz for now).                              */
+
+	/* Turn Off ALL on-chip peripheral clocks for re-configuration      */
+	/* Note: See label 'ENABLECLKS' for the re-enabling                 */
+#if 0
+	ldr     r1,  =CKEN
+	mov     r2,  #0
+	str     r2,  [r1]
+
+	/* default value in case no valid rotary switch setting is found    */
+	ldr     r2, =(CCCR_L27|CCCR_M2|CCCR_N10)  /* DEFAULT: {200/200/100} */
+
+	/* ... and write the core clock config register                     */
+	ldr     r1,  =CCCR
+	str     r2,  [r1]
+
+#endif
+
+#ifdef RTC
+	/* enable the 32Khz oscillator for RTC and PowerManager             */
+
+	ldr     r1,  =OSCC
+	mov     r2,  #OSCC_OON
+	str     r2,  [r1]
+
+	/* NOTE:  spin here until OSCC.OOK get set, meaning the PLL         */
+	/* has settled.                                                     */
+60:
+	ldr     r2, [r1]
+	ands    r2, r2, #1
+	beq     60b
+#endif
+
+	/* ---------------------------------------------------------------- */
+	/*                                                                  */
+	/* ---------------------------------------------------------------- */
+
+	/* Save SDRAM size */
+	ldr     r1, =DRAM_SIZE
+	str     r8, [r1]
+
+	/* Interrupt init: Mask all interrupts                              */
+	ldr	r0, =ICMR /* enable no sources */
+	mov r1, #0
+	str r1, [r0]
+
+	/* FIXME */
+
+#define NODEBUG
+#ifdef NODEBUG
+	/*Disable software and data breakpoints */
+	mov	r0,#0
+	mcr	p15,0,r0,c14,c8,0  /* ibcr0 */
+	mcr	p15,0,r0,c14,c9,0  /* ibcr1 */
+	mcr	p15,0,r0,c14,c4,0  /* dbcon */
+
+	/*Enable all debug functionality */
+	mov	r0,#0x80000000
+	mcr	p14,0,r0,c10,c0,0  /* dcsr */
+#endif
+
+	/* ---------------------------------------------------------------- */
+	/* End memsetup                                                     */
+	/* ---------------------------------------------------------------- */
+
+#ifdef DEBUG_BLINK_ENABLE
+	/* 7th blink */
+	bl 	blink
+#endif
+
+endlowlevel_init:
+
+	mov     pc, r10
+
+
+#ifdef DEBUG_BLINK_ENABLE
+
+/* debug LED code */
+
+/* delay about 200ms */
+delay:
+
+	/* reset OSCR to 0 */
+	ldr	r8, =OSCR
+	mov	r9, #0
+	str	r9, [r8]
+
+	/* make sure new value has stuck */
+1:
+	ldr	r8, =OSCR
+	ldr	r9, [r8]
+	mov	r8, #0x10000
+	cmp	r9, r8
+	bgt	1b
+
+	/* now, wait for delay to expire */
+1:
+	ldr	r8, =OSCR
+	ldr	r9, [r8]
+	mov	r8, #0xd4000
+	cmp	r8, r9
+	bgt	1b
+
+	mov	pc, lr
+
+/* blink code -- trashes r7, r8, r9 */
+
+.globl blink
+blink:
+
+	mov	r7, lr
+
+	/* set GPIO10 as outout */
+	ldr	r8,  =GPDR0
+	ldr	r9,  [r8]
+	orr	r9,  r9, #(1<<10)
+	str	r9,  [r8]
+
+	/* turn LED off */
+	mov	r9,  #(1<<10)
+	ldr	r8,  =GPCR0
+	str	r9, [r8]
+	bl	delay
+
+	/* turn LED on */
+	mov	r9,  #(1<<10)
+	ldr	r8,  =GPSR0
+	str	r9, [r8]
+	bl	delay
+
+	/* turn LED off */
+	mov	r9,  #(1<<10)
+	ldr	r8,  =GPCR0
+	str	r9, [r8]
+
+	mov	pc, r7
+
+#endif
diff --git a/board/pxa255_idp/memsetup.S b/board/pxa255_idp/memsetup.S
deleted file mode 100644
index 7e485a2..0000000
--- a/board/pxa255_idp/memsetup.S
+++ /dev/null
@@ -1,496 +0,0 @@
-/*
- * Most of this taken from Redboot hal_platform_setup.h with cleanup
- *
- * NOTE: I haven't clean this up considerably, just enough to get it
- * running. See hal_platform_setup.h for the source. See
- * board/cradle/memsetup.S for another PXA250 setup that is
- * much cleaner.
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include <config.h>
-#include <version.h>
-#include <asm/arch/pxa-regs.h>
-
-DRAM_SIZE:  .long   CFG_DRAM_SIZE
-
-/* wait for coprocessor write complete */
-	.macro CPWAIT reg
-	mrc  p15,0,\reg,c2,c0,0
-	mov  \reg,\reg
-	sub  pc,pc,#4
-	.endm
-
-/*
- * 	Memory setup
- */
-.globl memsetup
-memsetup:
-
-	mov      r10, lr
-
-#ifdef DEBUG_BLINK_ENABLE
-	/* 3rd blink */
-	bl	blink
-#endif
-
-	/* Set up GPIO pins first ----------------------------------------- */
-	ldr		r0,	=GPSR0
-	ldr		r1,	=CFG_GPSR0_VAL
-	str		r1,   [r0]
-
-	ldr		r0,	=GPSR1
-	ldr		r1,	=CFG_GPSR1_VAL
-	str		r1,   [r0]
-
-	ldr		r0,	=GPSR2
-	ldr		r1,	=CFG_GPSR2_VAL
-	str		r1,   [r0]
-
-	ldr		r0,	=GPCR0
-	ldr		r1,	=CFG_GPCR0_VAL
-	str		r1,   [r0]
-
-	ldr		r0,	=GPCR1
-	ldr		r1,	=CFG_GPCR1_VAL
-	str		r1,   [r0]
-
-	ldr		r0,	=GPCR2
-	ldr		r1,	=CFG_GPCR2_VAL
-	str		r1,   [r0]
-
-	ldr		r0,	=GPDR0
-	ldr		r1,	=CFG_GPDR0_VAL
-	str		r1,   [r0]
-
-	ldr		r0,	=GPDR1
-	ldr		r1,	=CFG_GPDR1_VAL
-	str		r1,   [r0]
-
-	ldr		r0,	=GPDR2
-	ldr		r1,	=CFG_GPDR2_VAL
-	str		r1,   [r0]
-
-	ldr		r0,	=GAFR0_L
-	ldr		r1,	=CFG_GAFR0_L_VAL
-	str		r1,   [r0]
-
-	ldr		r0,	=GAFR0_U
-	ldr		r1,	=CFG_GAFR0_U_VAL
-	str		r1,   [r0]
-
-	ldr		r0,	=GAFR1_L
-	ldr		r1,	=CFG_GAFR1_L_VAL
-	str		r1,   [r0]
-
-	ldr		r0,	=GAFR1_U
-	ldr		r1,	=CFG_GAFR1_U_VAL
-	str		r1,   [r0]
-
-	ldr		r0,	=GAFR2_L
-	ldr		r1,	=CFG_GAFR2_L_VAL
-	str		r1,   [r0]
-
-	ldr		r0,	=GAFR2_U
-	ldr		r1,	=CFG_GAFR2_U_VAL
-	str		r1,   [r0]
-
-	ldr	r0,	=PSSR		/* enable GPIO pins */
-	ldr		r1,	=CFG_PSSR_VAL
-	str		r1,   [r0]
-
-#ifdef DEBUG_BLINK_ENABLE
-	/* 4th debug blink */
-	bl 	blink
-#endif
-
-	/* ---------------------------------------------------------------- */
-	/* Enable memory interface                                          */
-	/*                                                                  */
-	/* The sequence below is based on the recommended init steps        */
-	/* detailed in the Intel PXA250 Operating Systems Developers Guide, */
-	/* Chapter 10.                                                      */
-	/* ---------------------------------------------------------------- */
-
-	/* ---------------------------------------------------------------- */
-	/* Step 1: Wait for at least 200 microsedonds to allow internal     */
-	/*         clocks to settle. Only necessary after hard reset...     */
-	/*         FIXME: can be optimized later                            */
-	/* ---------------------------------------------------------------- */
-
-	ldr r3, =OSCR			/* reset the OS Timer Count to zero */
-	mov r2, #0
-	str r2, [r3]
-	ldr r4, =0x300			/* really 0x2E1 is about 200usec,   */
-					/* so 0x300 should be plenty        */
-1:
-	ldr r2, [r3]
-	cmp r4, r2
-	bgt 1b
-
-mem_init:
-
-	ldr     r1,  =MEMC_BASE		/* get memory controller base addr. */
-
-	/* ---------------------------------------------------------------- */
-	/* Step 2a: Initialize Asynchronous static memory controller        */
-	/* ---------------------------------------------------------------- */
-
-	/* MSC registers: timing, bus width, mem type                       */
-
-	/* MSC0: nCS(0,1)                                                   */
-	ldr     r2,   =CFG_MSC0_VAL
-	str     r2,   [r1, #MSC0_OFFSET]
-	ldr     r2,   [r1, #MSC0_OFFSET]	/* read back to ensure      */
-						/* that data latches        */
-	/* MSC1: nCS(2,3)                                                   */
-	ldr     r2,  =CFG_MSC1_VAL
-	str     r2,  [r1, #MSC1_OFFSET]
-	ldr     r2,  [r1, #MSC1_OFFSET]
-
-	/* MSC2: nCS(4,5)                                                   */
-	ldr     r2,  =CFG_MSC2_VAL
-	str     r2,  [r1, #MSC2_OFFSET]
-	ldr     r2,  [r1, #MSC2_OFFSET]
-
-	/* ---------------------------------------------------------------- */
-	/* Step 2b: Initialize Card Interface                               */
-	/* ---------------------------------------------------------------- */
-
-	/* MECR: Memory Expansion Card Register                             */
-	ldr     r2,  =CFG_MECR_VAL
-	str     r2,  [r1, #MECR_OFFSET]
-	ldr	r2,	[r1, #MECR_OFFSET]
-
-	/* MCMEM0: Card Interface slot 0 timing                             */
-	ldr     r2,  =CFG_MCMEM0_VAL
-	str     r2,  [r1, #MCMEM0_OFFSET]
-	ldr	r2,	[r1, #MCMEM0_OFFSET]
-
-	/* MCMEM1: Card Interface slot 1 timing                             */
-	ldr     r2,  =CFG_MCMEM1_VAL
-	str     r2,  [r1, #MCMEM1_OFFSET]
-	ldr	r2,	[r1, #MCMEM1_OFFSET]
-
-	/* MCATT0: Card Interface Attribute Space Timing, slot 0            */
-	ldr     r2,  =CFG_MCATT0_VAL
-	str     r2,  [r1, #MCATT0_OFFSET]
-	ldr	r2,	[r1, #MCATT0_OFFSET]
-
-	/* MCATT1: Card Interface Attribute Space Timing, slot 1            */
-	ldr     r2,  =CFG_MCATT1_VAL
-	str     r2,  [r1, #MCATT1_OFFSET]
-	ldr	r2,	[r1, #MCATT1_OFFSET]
-
-	/* MCIO0: Card Interface I/O Space Timing, slot 0                   */
-	ldr     r2,  =CFG_MCIO0_VAL
-	str     r2,  [r1, #MCIO0_OFFSET]
-	ldr	r2,	[r1, #MCIO0_OFFSET]
-
-	/* MCIO1: Card Interface I/O Space Timing, slot 1                   */
-	ldr     r2,  =CFG_MCIO1_VAL
-	str     r2,  [r1, #MCIO1_OFFSET]
-	ldr	r2,	[r1, #MCIO1_OFFSET]
-
-#ifdef DEBUG_BLINK_ENABLE
-	/* 5th blink */
-	bl 	blink
-#endif
-
-	/* ---------------------------------------------------------------- */
-	/* Step 2c: Write FLYCNFG  FIXME: what's that???                    */
-	/* ---------------------------------------------------------------- */
-
-	/* ---------------------------------------------------------------- */
-	/* Step 2d: Initialize Timing for Sync Memory (SDCLK0)              */
-	/* ---------------------------------------------------------------- */
-
-	/* Before accessing MDREFR we need a valid DRI field, so we set     */
-	/* this to power on defaults + DRI field.                           */
-
-	ldr     r3,     =CFG_MDREFR_VAL
-	ldr     r2,     =0xFFF
-	and     r3,     r3,  r2
-	ldr	r4,	=0x03ca4000
-	orr     r4,     r4,  r3
-	str	r4,	[r1, #MDREFR_OFFSET]	/* write back MDREFR        */
-	ldr     r4,  [r1, #MDREFR_OFFSET]
-
-	/* Note: preserve the mdrefr value in r4                            */
-
-	/* ---------------------------------------------------------------- */
-	/* Step 3: Initialize Synchronous Static Memory (Flash/Peripherals) */
-	/* ---------------------------------------------------------------- */
-
-	/* Initialize SXCNFG register. Assert the enable bits               */
-
-	/* Write SXMRS to cause an MRS command to all enabled banks of      */
-	/* synchronous static memory. Note that SXLCR need not be written   */
-	/* at this time.                                                    */
-
-	/* FIXME: we use async mode for now                                 */
-
-	/* ---------------------------------------------------------------- */
-	/* Step 4: Initialize SDRAM                                         */
-	/* ---------------------------------------------------------------- */
-
-	/* set MDREFR according to user define with exception of a few bits */
-
-	ldr     r4,     =CFG_MDREFR_VAL
-	orr	r4,	r4,	#(MDREFR_SLFRSH)
-	bic	r4,	r4,	#(MDREFR_E1PIN|MDREFR_E0PIN)
-	str     r4,     [r1, #MDREFR_OFFSET]    /* write back MDREFR        */
-	ldr     r4,  [r1, #MDREFR_OFFSET]
-
-	/* Step 4b: de-assert MDREFR:SLFRSH.                                */
-
-	bic	r4,	r4,	#(MDREFR_SLFRSH)
-	str     r4,     [r1, #MDREFR_OFFSET]    /* write back MDREFR        */
-	ldr     r4,  [r1, #MDREFR_OFFSET]
-
-	/* Step 4c: assert MDREFR:E1PIN and E0PIO as desired                */
-
-	ldr     r4,     =CFG_MDREFR_VAL
-	str     r4,     [r1, #MDREFR_OFFSET]    /* write back MDREFR        */
-	ldr     r4,     [r1, #MDREFR_OFFSET]
-
-
-	/* Step 4d: write MDCNFG with MDCNFG:DEx deasserted (set to 0), to  */
-	/*          configure but not enable each SDRAM partition pair.     */
-
-	ldr	r4,	=CFG_MDCNFG_VAL
-	bic	r4,	r4,	#(MDCNFG_DE0|MDCNFG_DE1)
-
-	str     r4,     [r1, #MDCNFG_OFFSET]	/* write back MDCNFG        */
-	ldr     r4,     [r1, #MDCNFG_OFFSET]
-
-	/* Step 4e: Wait for the clock to the SDRAMs to stabilize,          */
-	/*          100..200 sec.                                          */
-
-	ldr r3, =OSCR			/* reset the OS Timer Count to zero */
-	mov r2, #0
-	    str r2, [r3]
-	ldr r4, =0x300			/* really 0x2E1 is about 200usec,   */
-					/* so 0x300 should be plenty        */
-1:
-	    ldr r2, [r3]
-	    cmp r4, r2
-	    bgt 1b
-
-	/* Step 4f: Trigger a number (usually 8) refresh cycles by          */
-	/*          attempting non-burst read or write accesses to disabled */
-	/*          SDRAM, as commonly specified in the power up sequence   */
-	/*          documented in SDRAM data sheets. The address(es) used   */
-	/*          for this purpose must not be cacheable.                 */
-
-	ldr	r3,	=CFG_DRAM_BASE
-	str	r2,	[r3]
-	str	r2,	[r3]
-	str	r2,	[r3]
-	str	r2,	[r3]
-	str	r2,	[r3]
-	str	r2,	[r3]
-	str	r2,	[r3]
-	str	r2,	[r3]
-
-	/* Step 4g: Write MDCNFG with enable bits asserted                  */
-	/*          (MDCNFG:DEx set to 1).                                  */
-
-	ldr     r3,  [r1, #MDCNFG_OFFSET]
-	orr	r3,	r3,	#(MDCNFG_DE0|MDCNFG_DE1)
-	str     r3,  [r1, #MDCNFG_OFFSET]
-
-	/* Step 4h: Write MDMRS.                                            */
-
-	ldr     r2,  =CFG_MDMRS_VAL
-	str     r2,  [r1, #MDMRS_OFFSET]
-
-	/* We are finished with Intel's memory controller initialisation    */
-#if 0
-	/* FIXME turn on serial ports */
-	/* look into moving this to board_init() */
-	ldr 	r2, =(PXA_CS5_PHYS + 0x03C0002c)
-	mov	r3, #0x13
-	str	r3, [r2]
-#endif
-
-#ifdef DEBUG_BLINK_ENABLE
-	/* 6th blink */
-	bl 	blink
-#endif
-
-	/* ---------------------------------------------------------------- */
-	/* Disable (mask) all interrupts at interrupt controller            */
-	/* ---------------------------------------------------------------- */
-
-initirqs:
-
-	mov     r1, #0		/* clear int. level register (IRQ, not FIQ) */
-	ldr     r2,  =ICLR
-	str     r1,  [r2]
-
-	ldr     r2,  =ICMR	/* mask all interrupts at the controller    */
-	str     r1,  [r2]
-
-	/* ---------------------------------------------------------------- */
-	/* Clock initialisation                                             */
-	/* ---------------------------------------------------------------- */
-
-initclks:
-
-	/* Disable the peripheral clocks, and set the core clock frequency  */
-	/* (hard-coding at 398.12MHz for now).                              */
-
-	/* Turn Off ALL on-chip peripheral clocks for re-configuration      */
-	/* Note: See label 'ENABLECLKS' for the re-enabling                 */
-#if 0
-	ldr     r1,  =CKEN
-	mov     r2,  #0
-	str     r2,  [r1]
-
-	/* default value in case no valid rotary switch setting is found    */
-	ldr     r2, =(CCCR_L27|CCCR_M2|CCCR_N10)  /* DEFAULT: {200/200/100} */
-
-	/* ... and write the core clock config register                     */
-	ldr     r1,  =CCCR
-	str     r2,  [r1]
-
-#endif
-
-#ifdef RTC
-	/* enable the 32Khz oscillator for RTC and PowerManager             */
-
-	ldr     r1,  =OSCC
-	mov     r2,  #OSCC_OON
-	str     r2,  [r1]
-
-	/* NOTE:  spin here until OSCC.OOK get set, meaning the PLL         */
-	/* has settled.                                                     */
-60:
-	ldr     r2, [r1]
-	ands    r2, r2, #1
-	beq     60b
-#endif
-
-	/* ---------------------------------------------------------------- */
-	/*                                                                  */
-	/* ---------------------------------------------------------------- */
-
-	/* Save SDRAM size */
-	ldr     r1, =DRAM_SIZE
-	 str	   r8, [r1]
-
-	/* Interrupt init: Mask all interrupts                              */
-	ldr	r0, =ICMR /* enable no sources */
-	mov r1, #0
-	str r1, [r0]
-
-	/* FIXME */
-
-#define NODEBUG
-#ifdef NODEBUG
-	/*Disable software and data breakpoints */
-	mov	r0,#0
-	mcr	p15,0,r0,c14,c8,0  /* ibcr0 */
-	mcr	p15,0,r0,c14,c9,0  /* ibcr1 */
-	mcr	p15,0,r0,c14,c4,0  /* dbcon */
-
-	/*Enable all debug functionality */
-	mov	r0,#0x80000000
-	mcr	p14,0,r0,c10,c0,0  /* dcsr */
-#endif
-
-	/* ---------------------------------------------------------------- */
-	/* End memsetup                                                     */
-	/* ---------------------------------------------------------------- */
-
-#ifdef DEBUG_BLINK_ENABLE
-	/* 7th blink */
-	bl 	blink
-#endif
-
-endmemsetup:
-
-	mov     pc, r10
-
-
-#ifdef DEBUG_BLINK_ENABLE
-
-/* debug LED code */
-
-/* delay about 200ms */
-delay:
-
-	/* reset OSCR to 0 */
-	ldr	r8, =OSCR
-	mov	r9, #0
-	str	r9, [r8]
-
-	/* make sure new value has stuck */
-1:
-	ldr	r8, =OSCR
-	ldr	r9, [r8]
-	mov	r8, #0x10000
-	cmp	r9, r8
-	bgt	1b
-
-	/* now, wait for delay to expire */
-1:
-	ldr	r8, =OSCR
-	ldr	r9, [r8]
-	mov	r8, #0xd4000
-	cmp	r8, r9
-	bgt	1b
-
-	mov	pc, lr
-
-/* blink code -- trashes r7, r8, r9 */
-
-.globl blink
-blink:
-
-	mov	r7, lr
-
-	/* set GPIO10 as outout */
-	ldr	r8,  =GPDR0
-	ldr	r9,  [r8]
-	orr	r9,  r9, #(1<<10)
-	str	r9,  [r8]
-
-	/* turn LED off */
-	mov	r9,  #(1<<10)
-	ldr	r8,  =GPCR0
-	str	r9, [r8]
-	bl	delay
-
-	/* turn LED on */
-	mov	r9,  #(1<<10)
-	ldr	r8,  =GPSR0
-	str	r9, [r8]
-	bl	delay
-
-	/* turn LED off */
-	mov	r9,  #(1<<10)
-	ldr	r8,  =GPCR0
-	str	r9, [r8]
-
-	mov	pc, r7
-
-#endif
diff --git a/board/pxa255_idp/u-boot.lds b/board/pxa255_idp/u-boot.lds
index 20ce108..2facd83 100644
--- a/board/pxa255_idp/u-boot.lds
+++ b/board/pxa255_idp/u-boot.lds
@@ -44,6 +44,7 @@ SECTIONS
 	. = ALIGN(4);
 	.got : { *(.got) }
 
+	. = .;
 	__u_boot_cmd_start = .;
 	.u_boot_cmd : { *(.u_boot_cmd) }
 	__u_boot_cmd_end = .;
diff --git a/board/tqm5200/cmd_stk52xx.c b/board/tqm5200/cmd_stk52xx.c
index b746679..27a6c41 100644
--- a/board/tqm5200/cmd_stk52xx.c
+++ b/board/tqm5200/cmd_stk52xx.c
@@ -561,7 +561,7 @@ void led_init(void)
 	gpt->gpt6.emsr |=  0x00000024;
 	gpt->gpt7.emsr |=  0x00000024;
 
-
+#ifndef CONFIG_TQM5200S
 	/* enable SM501 GPIO control (in both power modes) */
 	*(vu_long *) (SM501_MMIO_BASE+SM501_POWER_MODE0_GATE) |=
 		POWER_MODE_GATE_GPIO_PWM_I2C;
@@ -574,6 +574,7 @@ void led_init(void)
 
 	/* configure SM501 gpio pins 48-51 as output */
 	*(vu_long *) (SM501_MMIO_BASE+SM501_GPIO_DATA_DIR_HIGH) |= (0xF << 16);
+#endif /* !CONFIG_TQM5200S */
 }
 
 /*
@@ -650,7 +651,7 @@ int do_led(char *argv[])
 			gpt->gpt7.emsr &=  ~(1 << 4);
 		}
 		break;
-
+#ifndef CONFIG_TQM5200S
 	case 24:
 		if (strcmp (argv[3], "on") == 0) {
 			*(vu_long *) (SM501_MMIO_BASE+SM501_GPIO_DATA_LOW) |=
@@ -730,7 +731,7 @@ int do_led(char *argv[])
 				~(0x1 << 19);
 		}
 		break;
-
+#endif /* !CONFIG_TQM5200S */
 	default:
 		printf ("%s: invalid led number %s\n", __FUNCTION__, argv[2]);
 		return 1;
@@ -1110,7 +1111,7 @@ int do_rs232(char *argv[])
 	return error_status;
 }
 
-#ifndef CONFIG_FO300
+#if !defined(CONFIG_FO300) && !defined(CONFIG_TQM5200S)
 static void sm501_backlight (unsigned int state)
 {
 	if (state == BL_ON) {
@@ -1120,7 +1121,7 @@ static void sm501_backlight (unsigned int state)
 		*(vu_long *)(SM501_MMIO_BASE+SM501_PANEL_DISPLAY_CONTROL) &=
 			~((1 << 26) | (1 << 27));
 }
-#endif
+#endif /* !CONFIG_FO300 & !CONFIG_TQM5200S */
 
 int cmd_fkt(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 {
@@ -1160,7 +1161,7 @@ int cmd_fkt(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 			else
 				printf ("Error\n");
 			return rcode;
-#ifndef CONFIG_FO300
+#if !defined(CONFIG_FO300) && !defined(CONFIG_TQM5200S)
 		} else if (strncmp (argv[1], "backlight", 4) == 0) {
 			if (strncmp (argv[2], "on", 2) == 0) {
 				sm501_backlight (BL_ON);
@@ -1170,7 +1171,7 @@ int cmd_fkt(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 				sm501_backlight (BL_OFF);
 				return 0;
 			}
-#endif
+#endif /* !CONFIG_FO300 & !CONFIG_TQM5200S */
 		}
 		break;
 
@@ -1228,8 +1229,10 @@ U_BOOT_CMD(
 	"     - loopback plug for X83 required\n"
 	"fkt rs232 number\n"
 	"     - loopback plug(s) for X2 required\n"
+#ifndef CONFIG_TQM5200S
 	"fkt backlight on/off\n"
 	"     - switch backlight on or off\n"
+#endif /* !CONFIG_TQM5200S */
 );
 #elif defined(CONFIG_FO300)
 U_BOOT_CMD(
diff --git a/board/tqm5200/tqm5200.c b/board/tqm5200/tqm5200.c
index 29d6f00..d10cb59 100644
--- a/board/tqm5200/tqm5200.c
+++ b/board/tqm5200/tqm5200.c
@@ -543,6 +543,7 @@ int last_stage_init (void)
 		__asm__ volatile ("sync");
 	}
 
+#ifndef CONFIG_TQM5200S	/* The TQM5200S has no SM501 grafic controller */
 	/*
 	 * Check for Grafic Controller
 	 */
@@ -586,6 +587,7 @@ int last_stage_init (void)
 #endif
 
 	return 0;
+#endif /* !CONFIG_TQM5200S */
 }
 
 #ifdef CONFIG_VIDEO_SM501
diff --git a/board/tqm8xx/tqm8xx.c b/board/tqm8xx/tqm8xx.c
index 6b206f8..cebdcc0 100644
--- a/board/tqm8xx/tqm8xx.c
+++ b/board/tqm8xx/tqm8xx.c
@@ -354,6 +354,8 @@ long int initdram (int board_type)
 	udelay (10000);
 
 #ifdef	CONFIG_CAN_DRIVER
+	/* UPM initialization for CAN @ CLKOUT <= 66 MHz */
+
 	/* Initialize OR3 / BR3 */
 	memctl->memc_or3 = CFG_OR3_CAN;
 	memctl->memc_br3 = CFG_BR3_CAN;
@@ -362,7 +364,7 @@ long int initdram (int board_type)
 	memctl->memc_mbmr = MBMR_GPL_B4DIS;	/* GPL_B4 ouput line Disable */
 
 	/* Initialize UPMB for CAN: single read */
-	memctl->memc_mdr = 0xFFFFC004;
+	memctl->memc_mdr = 0xFFFFCC04;
 	memctl->memc_mcr = 0x0100 | UPMB;
 
 	memctl->memc_mdr = 0x0FFFD004;
@@ -374,23 +376,23 @@ long int initdram (int board_type)
 	memctl->memc_mdr = 0x3FFFC004;
 	memctl->memc_mcr = 0x0103 | UPMB;
 
-	memctl->memc_mdr = 0xFFFFDC05;
+	memctl->memc_mdr = 0xFFFFDC07;
 	memctl->memc_mcr = 0x0104 | UPMB;
 
 	/* Initialize UPMB for CAN: single write */
-	memctl->memc_mdr = 0xFFFCC004;
+	memctl->memc_mdr = 0xFFFCCC04;
 	memctl->memc_mcr = 0x0118 | UPMB;
 
-	memctl->memc_mdr = 0xCFFCD004;
+	memctl->memc_mdr = 0xCFFCDC04;
 	memctl->memc_mcr = 0x0119 | UPMB;
 
-	memctl->memc_mdr = 0x0FFCC000;
+	memctl->memc_mdr = 0x3FFCC000;
 	memctl->memc_mcr = 0x011A | UPMB;
 
-	memctl->memc_mdr = 0x7FFCC004;
+	memctl->memc_mdr = 0xFFFCC004;
 	memctl->memc_mcr = 0x011B | UPMB;
 
-	memctl->memc_mdr = 0xFFFDCC05;
+	memctl->memc_mdr = 0xFFFDC405;
 	memctl->memc_mcr = 0x011C | UPMB;
 #endif							/* CONFIG_CAN_DRIVER */
 
diff --git a/board/xsengine/flash.c b/board/xsengine/flash.c
index 2b9afc7..a188e24 100644
--- a/board/xsengine/flash.c
+++ b/board/xsengine/flash.c
@@ -46,11 +46,11 @@ unsigned long flash_init (void)
 	for (i = 0; i < CFG_MAX_FLASH_BANKS; i++) {
 		switch (i) {
 		case 0:
-			flash_get_size ((long *) PHYS_FLASH_1, &flash_info[i]);
+			flash_get_size ((vu_long *) PHYS_FLASH_1, &flash_info[i]);
 			flash_get_offsets (PHYS_FLASH_1, &flash_info[i]);
 			break;
 		case 1:
-			flash_get_size ((long *) PHYS_FLASH_2, &flash_info[i]);
+			flash_get_size ((vu_long *) PHYS_FLASH_2, &flash_info[i]);
 			flash_get_offsets (PHYS_FLASH_2, &flash_info[i]);
 			break;
 		default:
diff --git a/common/cmd_bootm.c b/common/cmd_bootm.c
index 6ebedfb..d816349 100644
--- a/common/cmd_bootm.c
+++ b/common/cmd_bootm.c
@@ -466,7 +466,7 @@ U_BOOT_CMD(
  	"\t'arg' can be the address of an initrd image\n"
 #if defined(CONFIG_OF_FLAT_TREE) || defined(CONFIG_OF_LIBFDT)
 	"\tWhen booting a Linux kernel which requires a flat device-tree\n"
-	"\ta third argument is required which is the address of the of the\n"
+	"\ta third argument is required which is the address of the\n"
 	"\tdevice-tree blob. To boot that kernel without an initrd image,\n"
 	"\tuse a '-' for the second argument. If you do not pass a third\n"
 	"\ta bd_info struct will be passed instead\n"
diff --git a/common/cmd_dtt.c b/common/cmd_dtt.c
index 8da95bf..804d467 100644
--- a/common/cmd_dtt.c
+++ b/common/cmd_dtt.c
@@ -57,7 +57,7 @@ int do_dtt (cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
 
 U_BOOT_CMD(
 	  dtt,	1,	1,	do_dtt,
-	  "dtt     - Digital Thermometer and Themostat\n",
+	  "dtt     - Digital Thermometer and Thermostat\n",
 	  "        - Read temperature from digital thermometer and thermostat.\n"
 );
 
diff --git a/cpu/arm920t/at91rm9200/usb.c b/cpu/arm920t/at91rm9200/usb.c
index 366262e..c121de6 100644
--- a/cpu/arm920t/at91rm9200/usb.c
+++ b/cpu/arm920t/at91rm9200/usb.c
@@ -28,7 +28,7 @@
 
 #include <asm/arch/hardware.h>
 
-int usb_cpu_init()
+int usb_cpu_init(void)
 {
 	/* Enable USB host clock. */
 	*AT91C_PMC_SCER = AT91C_PMC_UHP;	/* 48MHz clock enabled for UHP */
@@ -36,7 +36,7 @@ int usb_cpu_init()
 	return 0;
 }
 
-int usb_cpu_stop()
+int usb_cpu_stop(void)
 {
 	/* Initialization failed */
 	*AT91C_PMC_PCDR = 1 << AT91C_ID_UHP;	/* Peripheral Clock Disable Register */
@@ -44,9 +44,9 @@ int usb_cpu_stop()
 	return 0;
 }
 
-int usb_cpu_init_fail()
+int usb_cpu_init_fail(void)
 {
-	usb_cpu_stop();
+	return usb_cpu_stop();
 }
 
 # endif /* CONFIG_AT91RM9200 */
diff --git a/cpu/at32ap/at32ap7000/Makefile b/cpu/at32ap/at32ap7000/Makefile
deleted file mode 100644
index d276712..0000000
--- a/cpu/at32ap/at32ap7000/Makefile
+++ /dev/null
@@ -1,43 +0,0 @@
-#
-# Copyright (C) 2005-2006 Atmel Corporation
-#
-# See file CREDITS for list of people who contributed to this
-# project.
-#
-# This program is free software; you can redistribute it and/or
-# modify it under the terms of the GNU General Public License as
-# published by the Free Software Foundation; either version 2 of
-# the License, or (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
-# MA 02111-1307 USA
-#
-
-include $(TOPDIR)/config.mk
-
-LIB	:= $(obj)lib$(SOC).a
-
-COBJS	:= gpio.o
-SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
-OBJS	:= $(addprefix $(obj),$(SOBJS) $(COBJS))
-
-all: $(obj).depend $(LIB)
-
-$(LIB): $(OBJS)
-	$(AR) $(ARFLAGS) $@ $^
-
-#########################################################################
-
-# defines $(obj).depend target
-include $(SRCTREE)/rules.mk
-
-sinclude $(obj).depend
-
-#########################################################################
diff --git a/cpu/at32ap/at32ap7000/gpio.c b/cpu/at32ap/at32ap7000/gpio.c
deleted file mode 100644
index 52f5372..0000000
--- a/cpu/at32ap/at32ap7000/gpio.c
+++ /dev/null
@@ -1,137 +0,0 @@
-/*
- * Copyright (C) 2006 Atmel Corporation
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-#include <common.h>
-
-#include <asm/arch/gpio.h>
-
-/*
- * Lots of small functions here. We depend on --gc-sections getting
- * rid of the ones we don't need.
- */
-void gpio_enable_ebi(void)
-{
-#ifdef CFG_HSDRAMC
-#ifndef CFG_SDRAM_16BIT
-	gpio_select_periph_A(GPIO_PIN_PE0, 0);
-	gpio_select_periph_A(GPIO_PIN_PE1, 0);
-	gpio_select_periph_A(GPIO_PIN_PE2, 0);
-	gpio_select_periph_A(GPIO_PIN_PE3, 0);
-	gpio_select_periph_A(GPIO_PIN_PE4, 0);
-	gpio_select_periph_A(GPIO_PIN_PE5, 0);
-	gpio_select_periph_A(GPIO_PIN_PE6, 0);
-	gpio_select_periph_A(GPIO_PIN_PE7, 0);
-	gpio_select_periph_A(GPIO_PIN_PE8, 0);
-	gpio_select_periph_A(GPIO_PIN_PE9, 0);
-	gpio_select_periph_A(GPIO_PIN_PE10, 0);
-	gpio_select_periph_A(GPIO_PIN_PE11, 0);
-	gpio_select_periph_A(GPIO_PIN_PE12, 0);
-	gpio_select_periph_A(GPIO_PIN_PE13, 0);
-	gpio_select_periph_A(GPIO_PIN_PE14, 0);
-	gpio_select_periph_A(GPIO_PIN_PE15, 0);
-#endif
-	gpio_select_periph_A(GPIO_PIN_PE26, 0);
-#endif
-}
-
-void gpio_enable_usart0(void)
-{
-	gpio_select_periph_B(GPIO_PIN_PA8, 0);
-	gpio_select_periph_B(GPIO_PIN_PA9, 0);
-}
-
-void gpio_enable_usart1(void)
-{
-	gpio_select_periph_A(GPIO_PIN_PA17, 0);
-	gpio_select_periph_A(GPIO_PIN_PA18, 0);
-}
-
-void gpio_enable_usart2(void)
-{
-	gpio_select_periph_B(GPIO_PIN_PB26, 0);
-	gpio_select_periph_B(GPIO_PIN_PB27, 0);
-}
-
-void gpio_enable_usart3(void)
-{
-	gpio_select_periph_B(GPIO_PIN_PB18, 0);
-	gpio_select_periph_B(GPIO_PIN_PB19, 0);
-}
-
-void gpio_enable_macb0(void)
-{
-	gpio_select_periph_A(GPIO_PIN_PC3,  0);	/* TXD0	*/
-	gpio_select_periph_A(GPIO_PIN_PC4,  0);	/* TXD1	*/
-	gpio_select_periph_A(GPIO_PIN_PC7,  0);	/* TXEN	*/
-	gpio_select_periph_A(GPIO_PIN_PC8,  0);	/* TXCK */
-	gpio_select_periph_A(GPIO_PIN_PC9,  0);	/* RXD0	*/
-	gpio_select_periph_A(GPIO_PIN_PC10, 0);	/* RXD1	*/
-	gpio_select_periph_A(GPIO_PIN_PC13, 0);	/* RXER	*/
-	gpio_select_periph_A(GPIO_PIN_PC15, 0);	/* RXDV	*/
-	gpio_select_periph_A(GPIO_PIN_PC16, 0);	/* MDC	*/
-	gpio_select_periph_A(GPIO_PIN_PC17, 0);	/* MDIO	*/
-#if !defined(CONFIG_RMII)
-	gpio_select_periph_A(GPIO_PIN_PC0,  0);	/* COL	*/
-	gpio_select_periph_A(GPIO_PIN_PC1,  0);	/* CRS	*/
-	gpio_select_periph_A(GPIO_PIN_PC2,  0);	/* TXER	*/
-	gpio_select_periph_A(GPIO_PIN_PC5,  0);	/* TXD2	*/
-	gpio_select_periph_A(GPIO_PIN_PC6,  0);	/* TXD3 */
-	gpio_select_periph_A(GPIO_PIN_PC11, 0);	/* RXD2	*/
-	gpio_select_periph_A(GPIO_PIN_PC12, 0);	/* RXD3	*/
-	gpio_select_periph_A(GPIO_PIN_PC14, 0);	/* RXCK	*/
-	gpio_select_periph_A(GPIO_PIN_PC18, 0);	/* SPD	*/
-#endif
-}
-
-void gpio_enable_macb1(void)
-{
-	gpio_select_periph_B(GPIO_PIN_PD13, 0);	/* TXD0	*/
-	gpio_select_periph_B(GPIO_PIN_PD14, 0);	/* TXD1	*/
-	gpio_select_periph_B(GPIO_PIN_PD11, 0);	/* TXEN	*/
-	gpio_select_periph_B(GPIO_PIN_PD12, 0);	/* TXCK */
-	gpio_select_periph_B(GPIO_PIN_PD10, 0);	/* RXD0	*/
-	gpio_select_periph_B(GPIO_PIN_PD6,  0);	/* RXD1	*/
-	gpio_select_periph_B(GPIO_PIN_PD5,  0);	/* RXER	*/
-	gpio_select_periph_B(GPIO_PIN_PD4,  0);	/* RXDV	*/
-	gpio_select_periph_B(GPIO_PIN_PD3,  0);	/* MDC	*/
-	gpio_select_periph_B(GPIO_PIN_PD2,  0);	/* MDIO	*/
-#if !defined(CONFIG_RMII)
-	gpio_select_periph_B(GPIO_PIN_PC19, 0);	/* COL	*/
-	gpio_select_periph_B(GPIO_PIN_PC23, 0);	/* CRS	*/
-	gpio_select_periph_B(GPIO_PIN_PC26, 0);	/* TXER	*/
-	gpio_select_periph_B(GPIO_PIN_PC27, 0);	/* TXD2	*/
-	gpio_select_periph_B(GPIO_PIN_PC28, 0);	/* TXD3 */
-	gpio_select_periph_B(GPIO_PIN_PC29, 0);	/* RXD2	*/
-	gpio_select_periph_B(GPIO_PIN_PC30, 0);	/* RXD3	*/
-	gpio_select_periph_B(GPIO_PIN_PC24, 0);	/* RXCK	*/
-	gpio_select_periph_B(GPIO_PIN_PD15, 0);	/* SPD	*/
-#endif
-}
-
-void gpio_enable_mmci(void)
-{
-	gpio_select_periph_A(GPIO_PIN_PA10, 0);	/* CLK	 */
-	gpio_select_periph_A(GPIO_PIN_PA11, 0);	/* CMD	 */
-	gpio_select_periph_A(GPIO_PIN_PA12, 0);	/* DATA0 */
-	gpio_select_periph_A(GPIO_PIN_PA13, 0);	/* DATA1 */
-	gpio_select_periph_A(GPIO_PIN_PA14, 0);	/* DATA2 */
-	gpio_select_periph_A(GPIO_PIN_PA15, 0);	/* DATA3 */
-}
diff --git a/cpu/at32ap/at32ap700x/Makefile b/cpu/at32ap/at32ap700x/Makefile
new file mode 100644
index 0000000..d276712
--- /dev/null
+++ b/cpu/at32ap/at32ap700x/Makefile
@@ -0,0 +1,43 @@
+#
+# Copyright (C) 2005-2006 Atmel Corporation
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	:= $(obj)lib$(SOC).a
+
+COBJS	:= gpio.o
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(SOBJS) $(COBJS))
+
+all: $(obj).depend $(LIB)
+
+$(LIB): $(OBJS)
+	$(AR) $(ARFLAGS) $@ $^
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/cpu/at32ap/at32ap700x/gpio.c b/cpu/at32ap/at32ap700x/gpio.c
new file mode 100644
index 0000000..2d53726
--- /dev/null
+++ b/cpu/at32ap/at32ap700x/gpio.c
@@ -0,0 +1,144 @@
+/*
+ * Copyright (C) 2006 Atmel Corporation
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#include <common.h>
+
+#include <asm/arch/chip-features.h>
+#include <asm/arch/gpio.h>
+
+/*
+ * Lots of small functions here. We depend on --gc-sections getting
+ * rid of the ones we don't need.
+ */
+void gpio_enable_ebi(void)
+{
+#ifdef CFG_HSDRAMC
+#ifndef CFG_SDRAM_16BIT
+	gpio_select_periph_A(GPIO_PIN_PE0, 0);
+	gpio_select_periph_A(GPIO_PIN_PE1, 0);
+	gpio_select_periph_A(GPIO_PIN_PE2, 0);
+	gpio_select_periph_A(GPIO_PIN_PE3, 0);
+	gpio_select_periph_A(GPIO_PIN_PE4, 0);
+	gpio_select_periph_A(GPIO_PIN_PE5, 0);
+	gpio_select_periph_A(GPIO_PIN_PE6, 0);
+	gpio_select_periph_A(GPIO_PIN_PE7, 0);
+	gpio_select_periph_A(GPIO_PIN_PE8, 0);
+	gpio_select_periph_A(GPIO_PIN_PE9, 0);
+	gpio_select_periph_A(GPIO_PIN_PE10, 0);
+	gpio_select_periph_A(GPIO_PIN_PE11, 0);
+	gpio_select_periph_A(GPIO_PIN_PE12, 0);
+	gpio_select_periph_A(GPIO_PIN_PE13, 0);
+	gpio_select_periph_A(GPIO_PIN_PE14, 0);
+	gpio_select_periph_A(GPIO_PIN_PE15, 0);
+#endif
+	gpio_select_periph_A(GPIO_PIN_PE26, 0);
+#endif
+}
+
+#ifdef AT32AP700x_CHIP_HAS_USART
+void gpio_enable_usart0(void)
+{
+	gpio_select_periph_B(GPIO_PIN_PA8, 0);
+	gpio_select_periph_B(GPIO_PIN_PA9, 0);
+}
+
+void gpio_enable_usart1(void)
+{
+	gpio_select_periph_A(GPIO_PIN_PA17, 0);
+	gpio_select_periph_A(GPIO_PIN_PA18, 0);
+}
+
+void gpio_enable_usart2(void)
+{
+	gpio_select_periph_B(GPIO_PIN_PB26, 0);
+	gpio_select_periph_B(GPIO_PIN_PB27, 0);
+}
+
+void gpio_enable_usart3(void)
+{
+	gpio_select_periph_B(GPIO_PIN_PB18, 0);
+	gpio_select_periph_B(GPIO_PIN_PB19, 0);
+}
+#endif
+
+#ifdef AT32AP700x_CHIP_HAS_MACB
+void gpio_enable_macb0(void)
+{
+	gpio_select_periph_A(GPIO_PIN_PC3,  0);	/* TXD0	*/
+	gpio_select_periph_A(GPIO_PIN_PC4,  0);	/* TXD1	*/
+	gpio_select_periph_A(GPIO_PIN_PC7,  0);	/* TXEN	*/
+	gpio_select_periph_A(GPIO_PIN_PC8,  0);	/* TXCK */
+	gpio_select_periph_A(GPIO_PIN_PC9,  0);	/* RXD0	*/
+	gpio_select_periph_A(GPIO_PIN_PC10, 0);	/* RXD1	*/
+	gpio_select_periph_A(GPIO_PIN_PC13, 0);	/* RXER	*/
+	gpio_select_periph_A(GPIO_PIN_PC15, 0);	/* RXDV	*/
+	gpio_select_periph_A(GPIO_PIN_PC16, 0);	/* MDC	*/
+	gpio_select_periph_A(GPIO_PIN_PC17, 0);	/* MDIO	*/
+#if !defined(CONFIG_RMII)
+	gpio_select_periph_A(GPIO_PIN_PC0,  0);	/* COL	*/
+	gpio_select_periph_A(GPIO_PIN_PC1,  0);	/* CRS	*/
+	gpio_select_periph_A(GPIO_PIN_PC2,  0);	/* TXER	*/
+	gpio_select_periph_A(GPIO_PIN_PC5,  0);	/* TXD2	*/
+	gpio_select_periph_A(GPIO_PIN_PC6,  0);	/* TXD3 */
+	gpio_select_periph_A(GPIO_PIN_PC11, 0);	/* RXD2	*/
+	gpio_select_periph_A(GPIO_PIN_PC12, 0);	/* RXD3	*/
+	gpio_select_periph_A(GPIO_PIN_PC14, 0);	/* RXCK	*/
+	gpio_select_periph_A(GPIO_PIN_PC18, 0);	/* SPD	*/
+#endif
+}
+
+void gpio_enable_macb1(void)
+{
+	gpio_select_periph_B(GPIO_PIN_PD13, 0);	/* TXD0	*/
+	gpio_select_periph_B(GPIO_PIN_PD14, 0);	/* TXD1	*/
+	gpio_select_periph_B(GPIO_PIN_PD11, 0);	/* TXEN	*/
+	gpio_select_periph_B(GPIO_PIN_PD12, 0);	/* TXCK */
+	gpio_select_periph_B(GPIO_PIN_PD10, 0);	/* RXD0	*/
+	gpio_select_periph_B(GPIO_PIN_PD6,  0);	/* RXD1	*/
+	gpio_select_periph_B(GPIO_PIN_PD5,  0);	/* RXER	*/
+	gpio_select_periph_B(GPIO_PIN_PD4,  0);	/* RXDV	*/
+	gpio_select_periph_B(GPIO_PIN_PD3,  0);	/* MDC	*/
+	gpio_select_periph_B(GPIO_PIN_PD2,  0);	/* MDIO	*/
+#if !defined(CONFIG_RMII)
+	gpio_select_periph_B(GPIO_PIN_PC19, 0);	/* COL	*/
+	gpio_select_periph_B(GPIO_PIN_PC23, 0);	/* CRS	*/
+	gpio_select_periph_B(GPIO_PIN_PC26, 0);	/* TXER	*/
+	gpio_select_periph_B(GPIO_PIN_PC27, 0);	/* TXD2	*/
+	gpio_select_periph_B(GPIO_PIN_PC28, 0);	/* TXD3 */
+	gpio_select_periph_B(GPIO_PIN_PC29, 0);	/* RXD2	*/
+	gpio_select_periph_B(GPIO_PIN_PC30, 0);	/* RXD3	*/
+	gpio_select_periph_B(GPIO_PIN_PC24, 0);	/* RXCK	*/
+	gpio_select_periph_B(GPIO_PIN_PD15, 0);	/* SPD	*/
+#endif
+}
+#endif
+
+#ifdef AT32AP700x_CHIP_HAS_MMCI
+void gpio_enable_mmci(void)
+{
+	gpio_select_periph_A(GPIO_PIN_PA10, 0);	/* CLK	 */
+	gpio_select_periph_A(GPIO_PIN_PA11, 0);	/* CMD	 */
+	gpio_select_periph_A(GPIO_PIN_PA12, 0);	/* DATA0 */
+	gpio_select_periph_A(GPIO_PIN_PA13, 0);	/* DATA1 */
+	gpio_select_periph_A(GPIO_PIN_PA14, 0);	/* DATA2 */
+	gpio_select_periph_A(GPIO_PIN_PA15, 0);	/* DATA3 */
+}
+#endif
diff --git a/cpu/at32ap/atmel_mci.c b/cpu/at32ap/atmel_mci.c
index cf48be1..f59dfb5 100644
--- a/cpu/at32ap/atmel_mci.c
+++ b/cpu/at32ap/atmel_mci.c
@@ -198,11 +198,11 @@ mmc_bread(int dev, unsigned long start, lbaint_t blkcnt,
 
 	/* Put the device into Transfer state */
 	ret = mmc_cmd(MMC_CMD_SELECT_CARD, mmc_rca << 16, resp, R1 | NCR);
-	if (ret) goto fail;
+	if (ret) goto out;
 
 	/* Set block length */
 	ret = mmc_cmd(MMC_CMD_SET_BLOCKLEN, mmc_blkdev.blksz, resp, R1 | NCR);
-	if (ret) goto fail;
+	if (ret) goto out;
 
 	pr_debug("MCI_DTOR = %08lx\n", mmci_readl(DTOR));
 
@@ -211,7 +211,7 @@ mmc_bread(int dev, unsigned long start, lbaint_t blkcnt,
 			      start * mmc_blkdev.blksz, resp,
 			      (R1 | NCR | TRCMD_START | TRDIR_READ
 			       | TRTYP_BLOCK));
-		if (ret) goto fail;
+		if (ret) goto out;
 
 		ret = -EIO;
 		wordcount = 0;
@@ -219,7 +219,7 @@ mmc_bread(int dev, unsigned long start, lbaint_t blkcnt,
 			do {
 				status = mmci_readl(SR);
 				if (status & (ERROR_FLAGS | MMCI_BIT(OVRE)))
-					goto fail;
+					goto read_error;
 			} while (!(status & MMCI_BIT(RXRDY)));
 
 			if (status & MMCI_BIT(RXRDY)) {
@@ -244,9 +244,10 @@ out:
 	mmc_cmd(MMC_CMD_SELECT_CARD, 0, resp, NCR);
 	return i;
 
-fail:
+read_error:
 	mmc_cmd(MMC_CMD_SEND_STATUS, mmc_rca << 16, &card_status, R1 | NCR);
-	printf("mmc: bread failed, card status = %08x\n", card_status);
+	printf("mmc: bread failed, status = %08x, card status = %08x\n",
+	       status, card_status);
 	goto out;
 }
 
diff --git a/cpu/mpc86xx/spd_sdram.c b/cpu/mpc86xx/spd_sdram.c
index f37ab43..059097f 100644
--- a/cpu/mpc86xx/spd_sdram.c
+++ b/cpu/mpc86xx/spd_sdram.c
@@ -948,19 +948,25 @@ unsigned int enable_ddr(unsigned int ddr_num)
 	 * Read both dimm slots and decide whether
 	 * or not to enable this controller.
 	 */
-	memset((void *)&spd1,0,sizeof(spd1));
-	memset((void *)&spd2,0,sizeof(spd2));
+	memset((void *)&spd1, 0, sizeof(spd1));
+	memset((void *)&spd2, 0, sizeof(spd2));
 
 	if (ddr_num == 1) {
 		CFG_READ_SPD(SPD_EEPROM_ADDRESS1,
 			     0, 1, (uchar *) &spd1, sizeof(spd1));
+#if defined(SPD_EEPROM_ADDRESS2)
 		CFG_READ_SPD(SPD_EEPROM_ADDRESS2,
 			     0, 1, (uchar *) &spd2, sizeof(spd2));
+#endif
 	} else {
+#if defined(SPD_EEPROM_ADDRESS3)
 		CFG_READ_SPD(SPD_EEPROM_ADDRESS3,
 			     0, 1, (uchar *) &spd1, sizeof(spd1));
+#endif
+#if defined(SPD_EEPROM_ADDRESS4)
 		CFG_READ_SPD(SPD_EEPROM_ADDRESS4,
 			     0, 1, (uchar *) &spd2, sizeof(spd2));
+#endif
 	}
 
 	/*
@@ -1105,21 +1111,25 @@ spd_sdram(void)
 {
 	int memsize_ddr1_dimm1 = 0;
 	int memsize_ddr1_dimm2 = 0;
+	int memsize_ddr1 = 0;
+	unsigned int law_size_ddr1;
+	volatile immap_t *immap = (immap_t *)CFG_IMMR;
+	volatile ccsr_ddr_t *ddr1 = &immap->im_ddr1;
+	volatile ccsr_local_mcm_t *mcm = &immap->im_local_mcm;
+
+#if (CONFIG_NUM_DDR_CONTROLLERS > 1)
 	int memsize_ddr2_dimm1 = 0;
 	int memsize_ddr2_dimm2 = 0;
-	int memsize_total = 0;
-	int memsize_ddr1 = 0;
 	int memsize_ddr2 = 0;
+	unsigned int law_size_ddr2;
+#endif
+
 	unsigned int ddr1_enabled = 0;
 	unsigned int ddr2_enabled = 0;
-	unsigned int law_size_ddr1;
-	unsigned int law_size_ddr2;
-	volatile immap_t *immap = (immap_t *)CFG_IMMR;
-	volatile ccsr_local_mcm_t *mcm = &immap->im_local_mcm;
+	int memsize_total = 0;
 
 #ifdef CONFIG_DDR_INTERLEAVE
 	unsigned int law_size_interleaved;
-	volatile ccsr_ddr_t *ddr1 = &immap->im_ddr1;
 	volatile ccsr_ddr_t *ddr2 = &immap->im_ddr2;
 
 	memsize_ddr1_dimm1 = spd_init(SPD_EEPROM_ADDRESS1,
@@ -1194,9 +1204,11 @@ spd_sdram(void)
 				      (unsigned int)memsize_total * 1024*1024);
 	memsize_total += memsize_ddr1_dimm1;
 
+#if defined(SPD_EEPROM_ADDRESS2)
 	memsize_ddr1_dimm2 = spd_init(SPD_EEPROM_ADDRESS2,
 				      1, 2,
 				      (unsigned int)memsize_total * 1024*1024);
+#endif
 	memsize_total += memsize_ddr1_dimm2;
 
 	/*
diff --git a/cpu/pxa/config.mk b/cpu/pxa/config.mk
index fb810ca..f0b86b7 100644
--- a/cpu/pxa/config.mk
+++ b/cpu/pxa/config.mk
@@ -25,8 +25,7 @@
 PLATFORM_RELFLAGS += -fno-strict-aliasing  -fno-common -ffixed-r8 \
 	-msoft-float
 
-#PLATFORM_CPPFLAGS += -mapcs-32 -march=armv4 -mtune=strongarm1100
-PLATFORM_CPPFLAGS += -march=armv5 -mtune=xscale
+PLATFORM_CPPFLAGS += -march=armv5te -mtune=xscale
 # =========================================================================
 #
 # Supply options according to compiler version
diff --git a/cpu/pxa/serial.c b/cpu/pxa/serial.c
index 51e7f65..9ba457e 100644
--- a/cpu/pxa/serial.c
+++ b/cpu/pxa/serial.c
@@ -35,17 +35,17 @@
 
 DECLARE_GLOBAL_DATA_PTR;
 
-#define FFUART	0
-#define BTUART	1
-#define STUART	2
+#define FFUART_INDEX	0
+#define BTUART_INDEX	1
+#define STUART_INDEX	2
 
 #ifndef CONFIG_SERIAL_MULTI
 #if defined (CONFIG_FFUART)
-#define UART_INDEX	FFUART
+#define UART_INDEX	FFUART_INDEX
 #elif defined (CONFIG_BTUART)
-#define UART_INDEX	BTUART
+#define UART_INDEX	BTUART_INDEX
 #elif defined (CONFIG_STUART)
-#define UART_INDEX	STUART
+#define UART_INDEX	STUART_INDEX
 #else
 #error "Bad: you didn't configure serial ..."
 #endif
@@ -71,7 +71,7 @@ void pxa_setbrg_dev (unsigned int uart_index)
 		hang ();
 
 	switch (uart_index) {
-		case FFUART:
+		case FFUART_INDEX:
 #ifdef CONFIG_CPU_MONAHANS
 			CKENA |= CKENA_22_FFUART;
 #else
@@ -90,7 +90,7 @@ void pxa_setbrg_dev (unsigned int uart_index)
 			FFIER = IER_UUE;	/* Enable FFUART */
 		break;
 
-		case BTUART:
+		case BTUART_INDEX:
 #ifdef CONFIG_CPU_MONAHANS
 			CKENA |= CKENA_21_BTUART;
 #else
@@ -110,7 +110,7 @@ void pxa_setbrg_dev (unsigned int uart_index)
 
 		break;
 
-		case STUART:
+		case STUART_INDEX:
 #ifdef CONFIG_CPU_MONAHANS
 			CKENA |= CKENA_23_STUART;
 #else
@@ -154,20 +154,20 @@ int pxa_init_dev (unsigned int uart_index)
 void pxa_putc_dev (unsigned int uart_index,const char c)
 {
 	switch (uart_index) {
-		case FFUART:
+		case FFUART_INDEX:
 		/* wait for room in the tx FIFO on FFUART */
 			while ((FFLSR & LSR_TEMT) == 0)
 				WATCHDOG_RESET ();	/* Reset HW Watchdog, if needed */
 			FFTHR = c;
 			break;
 
-		case BTUART:
+		case BTUART_INDEX:
 			while ((BTLSR & LSR_TEMT ) == 0 )
 				WATCHDOG_RESET ();	/* Reset HW Watchdog, if needed */
 			BTTHR = c;
 			break;
 
-		case STUART:
+		case STUART_INDEX:
 			while ((STLSR & LSR_TEMT ) == 0 )
 				WATCHDOG_RESET ();	/* Reset HW Watchdog, if needed */
 			STTHR = c;
@@ -187,11 +187,11 @@ void pxa_putc_dev (unsigned int uart_index,const char c)
 int pxa_tstc_dev (unsigned int uart_index)
 {
 	switch (uart_index) {
-		case FFUART:
+		case FFUART_INDEX:
 			return FFLSR & LSR_DR;
-		case BTUART:
+		case BTUART_INDEX:
 			return BTLSR & LSR_DR;
-		case STUART:
+		case STUART_INDEX:
 			return STLSR & LSR_DR;
 	}
 	return -1;
@@ -205,16 +205,16 @@ int pxa_tstc_dev (unsigned int uart_index)
 int pxa_getc_dev (unsigned int uart_index)
 {
 	switch (uart_index) {
-		case FFUART:
+		case FFUART_INDEX:
 			while (!(FFLSR & LSR_DR))
 			WATCHDOG_RESET ();	/* Reset HW Watchdog, if needed */
 			return (char) FFRBR & 0xff;
 
-		case BTUART:
+		case BTUART_INDEX:
 			while (!(BTLSR & LSR_DR))
 			WATCHDOG_RESET ();	/* Reset HW Watchdog, if needed */
 			return (char) BTRBR & 0xff;
-		case STUART:
+		case STUART_INDEX:
 			while (!(STLSR & LSR_DR))
 			WATCHDOG_RESET ();	/* Reset HW Watchdog, if needed */
 			return (char) STRBR & 0xff;
@@ -233,32 +233,32 @@ pxa_puts_dev (unsigned int uart_index,const char *s)
 #if defined (CONFIG_FFUART)
 static int ffuart_init(void)
 {
-	return pxa_init_dev(FFUART);
+	return pxa_init_dev(FFUART_INDEX);
 }
 
 static void ffuart_setbrg(void)
 {
-	return pxa_setbrg_dev(FFUART);
+	return pxa_setbrg_dev(FFUART_INDEX);
 }
 
 static void ffuart_putc(const char c)
 {
-	return pxa_putc_dev(FFUART,c);
+	return pxa_putc_dev(FFUART_INDEX,c);
 }
 
 static void ffuart_puts(const char *s)
 {
-	return pxa_puts_dev(FFUART,s);
+	return pxa_puts_dev(FFUART_INDEX,s);
 }
 
 static int ffuart_getc(void)
 {
-	return pxa_getc_dev(FFUART);
+	return pxa_getc_dev(FFUART_INDEX);
 }
 
 static int ffuart_tstc(void)
 {
-	return pxa_tstc_dev(FFUART);
+	return pxa_tstc_dev(FFUART_INDEX);
 }
 
 struct serial_device serial_ffuart_device =
@@ -277,32 +277,32 @@ struct serial_device serial_ffuart_device =
 #if defined (CONFIG_BTUART)
 static int btuart_init(void)
 {
-	return pxa_init_dev(BTUART);
+	return pxa_init_dev(BTUART_INDEX);
 }
 
 static void btuart_setbrg(void)
 {
-	return pxa_setbrg_dev(BTUART);
+	return pxa_setbrg_dev(BTUART_INDEX);
 }
 
 static void btuart_putc(const char c)
 {
-	return pxa_putc_dev(BTUART,c);
+	return pxa_putc_dev(BTUART_INDEX,c);
 }
 
 static void btuart_puts(const char *s)
 {
-	return pxa_puts_dev(BTUART,s);
+	return pxa_puts_dev(BTUART_INDEX,s);
 }
 
 static int btuart_getc(void)
 {
-	return pxa_getc_dev(BTUART);
+	return pxa_getc_dev(BTUART_INDEX);
 }
 
 static int btuart_tstc(void)
 {
-	return pxa_tstc_dev(BTUART);
+	return pxa_tstc_dev(BTUART_INDEX);
 }
 
 struct serial_device serial_btuart_device =
@@ -321,32 +321,32 @@ struct serial_device serial_btuart_device =
 #if defined (CONFIG_STUART)
 static int stuart_init(void)
 {
-	return pxa_init_dev(STUART);
+	return pxa_init_dev(STUART_INDEX);
 }
 
 static void stuart_setbrg(void)
 {
-	return pxa_setbrg_dev(STUART);
+	return pxa_setbrg_dev(STUART_INDEX);
 }
 
 static void stuart_putc(const char c)
 {
-	return pxa_putc_dev(STUART,c);
+	return pxa_putc_dev(STUART_INDEX,c);
 }
 
 static void stuart_puts(const char *s)
 {
-	return pxa_puts_dev(STUART,s);
+	return pxa_puts_dev(STUART_INDEX,s);
 }
 
 static int stuart_getc(void)
 {
-	return pxa_getc_dev(STUART);
+	return pxa_getc_dev(STUART_INDEX);
 }
 
 static int stuart_tstc(void)
 {
-	return pxa_tstc_dev(STUART);
+	return pxa_tstc_dev(STUART_INDEX);
 }
 
 struct serial_device serial_stuart_device =
diff --git a/cpu/pxa/start.S b/cpu/pxa/start.S
index ffaa30f..b922485 100644
--- a/cpu/pxa/start.S
+++ b/cpu/pxa/start.S
@@ -166,13 +166,17 @@ _start_armboot: .word start_armboot
 /*									    */
 /****************************************************************************/
 /* mk@tbd: Fix this! */
-#ifdef CONFIG_CPU_MONAHANS
+#if defined(CONFIG_PXA250) || defined(CONFIG_CPU_MONAHANS)
 #undef ICMR
 #undef OSMR3
 #undef OSCR
 #undef OWER
 #undef OIER
 #endif
+#ifdef CONFIG_PXA250
+#undef RCSR
+#undef CCCR
+#endif
 
 /* Interrupt-Controller base address					    */
 IC_BASE:	   .word	   0x40d00000
diff --git a/cpu/pxa/usb.c b/cpu/pxa/usb.c
index 65f457f..72b7dfa 100644
--- a/cpu/pxa/usb.c
+++ b/cpu/pxa/usb.c
@@ -27,8 +27,9 @@
 # if defined(CONFIG_CPU_MONAHANS) || defined(CONFIG_PXA27X)
 
 #include <asm/arch/pxa-regs.h>
+#include <usb.h>
 
-int usb_cpu_init()
+int usb_cpu_init(void)
 {
 #if defined(CONFIG_CPU_MONAHANS)
 	/* Enable USB host clock. */
@@ -65,12 +66,28 @@ int usb_cpu_init()
 	return 0;
 }
 
-int usb_cpu_stop()
+int usb_cpu_stop(void)
 {
+	UHCHR |= UHCHR_FHR;
+	udelay(11);
+	UHCHR &= ~UHCHR_FHR;
+
+	UHCCOMS |= 1;
+	udelay(10);
+
+#if defined(CONFIG_CPU_MONAHANS)
+	UHCHR |= UHCHR_SSEP0;
+#endif
+#if defined(CONFIG_PXA27X)
+	UHCHR |= UHCHR_SSEP2;
+#endif
+	UHCHR |= UHCHR_SSEP1;
+	UHCHR |= UHCHR_SSE;
+
 	return 0;
 }
 
-int usb_cpu_init_fail()
+int usb_cpu_init_fail(void)
 {
 	return 0;
 }
diff --git a/drivers/Makefile b/drivers/Makefile
index 6bf05cc..00978d8 100755
--- a/drivers/Makefile
+++ b/drivers/Makefile
@@ -1,5 +1,5 @@
 #
-# (C) Copyright 2000-2006
+# (C) Copyright 2000-2007
 # Wolfgang Denk, DENX Software Engineering, wd@denx.de.
 #
 # See file CREDITS for list of people who contributed to this
@@ -27,34 +27,33 @@ include $(TOPDIR)/config.mk
 
 LIB	= $(obj)libdrivers.a
 
-COBJS	= 3c589.o 5701rls.o ali512x.o at45.o ata_piix.o atmel_usart.o \
+COBJS	= 3c589.o 5701rls.o ali512x.o at45.o ata_piix.o \
+	  ati_radeon_fb.o atmel_usart.o \
 	  bcm570x.o bcm570x_autoneg.o cfb_console.o cfi_flash.o \
 	  cs8900.o ct69000.o dataflash.o dc2114x.o dm9000x.o \
-	  e1000.o eepro100.o enc28j60.o \
-	  i8042.o inca-ip_sw.o isp116x-hcd.o keyboard.o \
-	  lan91c96.o macb.o \
+	  ds1722.o e1000.o eepro100.o enc28j60.o \
+	  fsl_i2c.o fsl_pci_init.o \
+	  i8042.o inca-ip_sw.o isp116x-hcd.o \
+	  keyboard.o ks8695eth.o \
+	  lan91c96.o macb.o mpc8xx_pcmcia.o mw_eeprom.o \
 	  natsemi.o ne2000.o netarm_eth.o netconsole.o \
 	  ns16550.o ns8382x.o ns87308.o ns7520_eth.o omap1510_i2c.o \
-	  omap24xx_i2c.o pci.o pci_auto.o pci_indirect.o \
-	  pcnet.o plb2800_eth.o \
-	  ps2ser.o ps2mult.o pc_keyb.o \
-	  rtl8019.o rtl8139.o rtl8169.o \
+	  omap24xx_i2c.o pc_keyb.o \
+	  pci.o pci_auto.o pci_indirect.o \
+	  pcnet.o plb2800_eth.o ps2ser.o ps2mult.o pxa_pcmcia.o \
+	  rpx_pcmcia.o rtl8019.o rtl8139.o rtl8169.o \
 	  s3c4510b_eth.o s3c4510b_uart.o \
 	  sed13806.o sed156x.o \
 	  serial.o serial_max3100.o \
 	  serial_pl010.o serial_pl011.o serial_xuartlite.o \
 	  sil680.o sl811_usb.o sm501.o smc91111.o smiLynxEM.o \
 	  status_led.o sym53c8xx.o systemace.o ahci.o \
-	  ti_pci1410a.o tigon3.o tsec.o \
+	  ti_pci1410a.o tigon3.o tqm8xx_pcmcia.o tsec.o \
 	  tsi108_eth.o tsi108_i2c.o tsi108_pci.o \
 	  usb_ohci.o \
 	  usbdcore.o usbdcore_ep0.o usbdcore_mpc8xx.o usbdcore_omap1510.o \
 	  usbtty.o \
-	  videomodes.o w83c553f.o \
-	  ks8695eth.o \
-	  pxa_pcmcia.o mpc8xx_pcmcia.o tqm8xx_pcmcia.o	\
-	  rpx_pcmcia.o \
-	  fsl_i2c.o fsl_pci_init.o ati_radeon_fb.o
+	  videomodes.o w83c553f.o
 
 SRCS	:= $(COBJS:.o=.c)
 OBJS	:= $(addprefix $(obj),$(COBJS))
diff --git a/drivers/ds1722.c b/drivers/ds1722.c
index 227d816..c19ee01 100644
--- a/drivers/ds1722.c
+++ b/drivers/ds1722.c
@@ -1,10 +1,10 @@
 
 #include <common.h>
 
-#include <ssi.h>
-
 #ifdef CONFIG_DS1722
 
+#include <ssi.h>
+
 static void ds1722_select(int dev)
 {
 	ssi_set_interface(4096, 0, 0, 0);
diff --git a/drivers/fsl_pci_init.c b/drivers/fsl_pci_init.c
index 3a13eea..1e77884 100644
--- a/drivers/fsl_pci_init.c
+++ b/drivers/fsl_pci_init.c
@@ -54,6 +54,7 @@ fsl_pci_init(struct pci_controller *hose)
 	u8 temp8;
 	int r;
 	int bridge;
+	int inbound = 0;
 	volatile ccsr_fsl_pci_t *pci = (ccsr_fsl_pci_t *) hose->cfg_addr;
 	pci_dev_t dev = PCI_BDF(busno,0,0);
 
@@ -74,6 +75,7 @@ fsl_pci_init(struct pci_controller *hose)
 				PIWAR_READ_SNOOP | PIWAR_WRITE_SNOOP |
 				(__ilog2(hose->regions[r].size) - 1);
 			pi++;
+			inbound = hose->regions[r].size > 0;
 		} else { /* Outbound */
 			po->powbar = (hose->regions[r].phys_start >> 12) & 0x000fffff;
 			po->potar = (hose->regions[r].bus_start >> 12) & 0x000fffff;
@@ -138,6 +140,12 @@ fsl_pci_init(struct pci_controller *hose)
 	pciauto_setup_device(hose, dev, 0, hose->pci_mem,
 			     hose->pci_prefetch, hose->pci_io);
 
+	if (inbound) {
+		pci_hose_read_config_word(hose, dev, PCI_COMMAND, &temp16);
+		pci_hose_write_config_word(hose, dev, PCI_COMMAND,
+					   temp16 | PCI_COMMAND_MEMORY);
+	}
+
 #ifndef CONFIG_PCI_NOSCAN
 	printf ("               Scanning PCI bus %02x\n", hose->current_busno);
 	hose->last_busno = pci_hose_scan_bus(hose,hose->current_busno);
diff --git a/drivers/isp116x-hcd.c b/drivers/isp116x-hcd.c
index 8e2bc7a..b21af10 100644
--- a/drivers/isp116x-hcd.c
+++ b/drivers/isp116x-hcd.c
@@ -113,9 +113,9 @@ static const char hcd_name[] = "isp116x-hcd";
 
 struct isp116x isp116x_dev;
 struct isp116x_platform_data isp116x_board;
-int got_rhsc = 0;		/* root hub status change */
+static int got_rhsc;		/* root hub status change */
 struct usb_device *devgone;	/* device which was disconnected */
-int rh_devnum = 0;		/* address of Root Hub endpoint */
+static int rh_devnum;		/* address of Root Hub endpoint */
 
 /* ------------------------------------------------------------------------- */
 
@@ -522,11 +522,13 @@ static int unpack_fifo(struct isp116x *isp116x, struct usb_device *dev,
 		done += PTD_GET_LEN(&ptd[i]);
 
 		cc = PTD_GET_CC(&ptd[i]);
-		if (cc == TD_DATAUNDERRUN) {	/* underrun is no error... */
-			DBG("allowed data underrun");
-			cc = TD_CC_NOERROR;
-		}
-		if (cc != TD_CC_NOERROR && ret == TD_CC_NOERROR)
+
+		/* Data underrun means basically that we had more buffer space than
+		 * the function had data. It is perfectly normal but upper levels have
+		 * to know how much we actually transferred.
+		 */
+		if (cc == TD_NOTACCESSED ||
+				(cc != TD_CC_NOERROR && (ret == TD_CC_NOERROR || ret == TD_DATAUNDERRUN)))
 			ret = cc;
 	}
 
@@ -592,11 +594,19 @@ static int isp116x_interrupt(struct isp116x *isp116x)
 	return ret;
 }
 
-#define PTD_NUM			64	/* it should be enougth... */
-struct ptd ptd[PTD_NUM];
+/* With one PTD we can transfer almost 1K in one go;
+ * HC does the splitting into endpoint digestible transactions
+ */
+struct ptd ptd[1];
+
 static inline int max_transfer_len(struct usb_device *dev, unsigned long pipe)
 {
-	return min(PTD_NUM * usb_maxpacket(dev, pipe), PTD_NUM * 16);
+	unsigned mpck = usb_maxpacket(dev, pipe);
+
+	/* One PTD can transfer 1023 bytes but try to always
+	 * transfer multiples of endpoint buffer size
+	 */
+	return 1023 / mpck * mpck;
 }
 
 /* Do an USB transfer
@@ -610,13 +620,21 @@ static int isp116x_submit_job(struct usb_device *dev, unsigned long pipe,
 	int max = usb_maxpacket(dev, pipe);
 	int dir_out = usb_pipeout(pipe);
 	int speed_low = usb_pipeslow(pipe);
-	int i, done, stat, timeout, cc;
-	int retries = 10;
+	int i, done = 0, stat, timeout, cc;
+
+	/* 500 frames or 0.5s timeout when function is busy and NAKs transactions for a while */
+	int retries = 500;
 
 	DBG("------------------------------------------------");
 	dump_msg(dev, pipe, buffer, len, "SUBMIT");
 	DBG("------------------------------------------------");
 
+	if (len >= 1024) {
+		ERR("Too big job");
+		dev->status = USB_ST_CRC_ERR;
+		return -1;
+	}
+
 	if (isp116x->disabled) {
 		ERR("EPIPE");
 		dev->status = USB_ST_CRC_ERR;
@@ -653,29 +671,15 @@ static int isp116x_submit_job(struct usb_device *dev, unsigned long pipe,
 	isp116x_write_reg32(isp116x, HCINTSTAT, 0xff);
 
 	/* Prepare the PTD data */
-	done = 0;
-	i = 0;
-	do {
-		ptd[i].count = PTD_CC_MSK | PTD_ACTIVE_MSK |
-		    PTD_TOGGLE(usb_gettoggle(dev, epnum, dir_out));
-		ptd[i].mps = PTD_MPS(max) | PTD_SPD(speed_low) | PTD_EP(epnum);
-		ptd[i].len = PTD_LEN(max > len - done ? len - done : max) |
-		    PTD_DIR(dir);
-		ptd[i].faddr = PTD_FA(usb_pipedevice(pipe));
-
-		usb_dotoggle(dev, epnum, dir_out);
-		done += PTD_GET_LEN(&ptd[i]);
-		i++;
-		if (i >= PTD_NUM) {
-			ERR("****** Cannot pack buffer! ******");
-			dev->status = USB_ST_BUF_ERR;
-			return -1;
-		}
-	} while (done < len);
-	ptd[i - 1].mps |= PTD_LAST_MSK;
+	ptd->count = PTD_CC_MSK | PTD_ACTIVE_MSK |
+		PTD_TOGGLE(usb_gettoggle(dev, epnum, dir_out));
+	ptd->mps = PTD_MPS(max) | PTD_SPD(speed_low) | PTD_EP(epnum) | PTD_LAST_MSK;
+	ptd->len = PTD_LEN(len) | PTD_DIR(dir);
+	ptd->faddr = PTD_FA(usb_pipedevice(pipe));
 
+retry_same:
 	/* Pack data into FIFO ram */
-	pack_fifo(isp116x, dev, pipe, ptd, i, buffer, len);
+	pack_fifo(isp116x, dev, pipe, ptd, 1, buffer, len);
 #ifdef EXTRA_DELAY
 	wait_ms(EXTRA_DELAY);
 #endif
@@ -738,17 +742,42 @@ static int isp116x_submit_job(struct usb_device *dev, unsigned long pipe,
 	}
 
 	/* Unpack data from FIFO ram */
-	cc = unpack_fifo(isp116x, dev, pipe, ptd, i, buffer, len);
+	cc = unpack_fifo(isp116x, dev, pipe, ptd, 1, buffer, len);
+
+	i = PTD_GET_COUNT(ptd);
+	done += i;
+	buffer += i;
+	len -= i;
 
-	/* Mmm... sometime we get 0x0f as cc which is a non sense!
-	 * Just retry the transfer...
+	/* There was some kind of real problem; Prepare the PTD again
+	 * and retry from the failed transaction on
 	 */
-	if (cc == 0x0f && retries-- > 0) {
-		usb_dotoggle(dev, epnum, dir_out);
-		goto retry;
+	if (cc && cc != TD_NOTACCESSED && cc != TD_DATAUNDERRUN) {
+		if (retries >= 100) {
+			retries -= 100;
+			/* The chip will have toggled the toggle bit for the failed
+			 * transaction too. We have to toggle it back.
+			 */
+			usb_settoggle(dev, epnum, dir_out, !PTD_GET_TOGGLE(ptd));
+			goto retry;
+		}
+	}
+	/* "Normal" errors; TD_NOTACCESSED would mean in effect that the function have NAKed
+	 * the transactions from the first on for the whole frame. It may be busy and we retry
+	 * with the same PTD. PTD_ACTIVE (and not TD_NOTACCESSED) would mean that some of the
+	 * PTD didn't make it because the function was busy or the frame ended before the PTD
+	 * finished. We prepare the rest of the data and try again.
+	 */
+	else if (cc == TD_NOTACCESSED || PTD_GET_ACTIVE(ptd) || (cc != TD_DATAUNDERRUN && PTD_GET_COUNT(ptd) < PTD_GET_LEN(ptd))) {
+		if (retries) {
+			--retries;
+			if (cc == TD_NOTACCESSED && PTD_GET_ACTIVE(ptd) && !PTD_GET_COUNT(ptd)) goto retry_same;
+			usb_settoggle(dev, epnum, dir_out, PTD_GET_TOGGLE(ptd));
+			goto retry;
+		}
 	}
 
-	if (cc != TD_CC_NOERROR) {
+	if (cc != TD_CC_NOERROR && cc != TD_DATAUNDERRUN) {
 		DBG("****** completition code error %x ******", cc);
 		switch (cc) {
 		case TD_CC_BITSTUFFING:
@@ -766,6 +795,7 @@ static int isp116x_submit_job(struct usb_device *dev, unsigned long pipe,
 		}
 		return -cc;
 	}
+	else usb_settoggle(dev, epnum, dir_out, PTD_GET_TOGGLE(ptd));
 
 	dump_msg(dev, pipe, buffer, len, "SUBMIT(ret)");
 
@@ -1369,6 +1399,8 @@ int usb_lowlevel_init(void)
 
 	DBG("");
 
+	got_rhsc = rh_devnum = 0;
+
 	/* Init device registers addr */
 	isp116x->addr_reg = (u16 *) ISP116X_HCD_ADDR;
 	isp116x->data_reg = (u16 *) ISP116X_HCD_DATA;
diff --git a/drivers/mw_eeprom.c b/drivers/mw_eeprom.c
index 2a1f489..2b33488 100644
--- a/drivers/mw_eeprom.c
+++ b/drivers/mw_eeprom.c
@@ -1,11 +1,11 @@
 /* Three-wire (MicroWire) serial eeprom driver (for 93C46 and compatibles) */
 
 #include <common.h>
-#include <ssi.h>
-
 
 #ifdef CONFIG_MW_EEPROM
 
+#include <ssi.h>
+
 /*
  * Serial EEPROM opcodes, including start bit
  */
diff --git a/drivers/ne2000.c b/drivers/ne2000.c
index b7ed876..695a1dc 100644
--- a/drivers/ne2000.c
+++ b/drivers/ne2000.c
@@ -745,17 +745,15 @@ static void pcnet_reset_8390(void)
 
 	PRINTK("nic base is %lx\n", nic_base);
 
-#if 1
 	n2k_outb(E8390_NODMA+E8390_PAGE0+E8390_STOP, E8390_CMD);
 	PRINTK("cmd (at %lx) is %x\n", nic_base+ E8390_CMD, n2k_inb(E8390_CMD));
 	n2k_outb(E8390_NODMA+E8390_PAGE1+E8390_STOP, E8390_CMD);
 	PRINTK("cmd (at %lx) is %x\n", nic_base+ E8390_CMD, n2k_inb(E8390_CMD));
 	n2k_outb(E8390_NODMA+E8390_PAGE0+E8390_STOP, E8390_CMD);
 	PRINTK("cmd (at %lx) is %x\n", nic_base+ E8390_CMD, n2k_inb(E8390_CMD));
-#endif
 	n2k_outb(E8390_NODMA+E8390_PAGE0+E8390_STOP, E8390_CMD);
 
-	n2k_outb(n2k_inb(nic_base + PCNET_RESET), PCNET_RESET);
+	n2k_outb(n2k_inb(PCNET_RESET), PCNET_RESET);
 
 	for (i = 0; i < 100; i++) {
 		if ((r = (n2k_inb(EN0_ISR) & ENISR_RESET)) != 0)
@@ -833,6 +831,7 @@ static int plen[NB];
 static int nrx = 0;
 
 static int pkey = -1;
+static int initialized=0;
 
 void uboot_push_packet_len(int len) {
 	PRINTK("pushed len = %d, nrx = %d\n", len, nrx);
@@ -846,7 +845,9 @@ void uboot_push_packet_len(int len) {
 	}
 	plen[nrx] = len;
 	dp83902a_recv(&pbuf[nrx*2000], len);
-	nrx++;
+
+	/*Just pass it to the upper layer*/
+	NetReceive(&pbuf[nrx*2000], plen[nrx]);
 }
 
 void uboot_push_tx_done(int key, int val) {
@@ -903,37 +904,21 @@ int eth_init(bd_t *bd) {
 	if (dp83902a_init() == false)
 		return -1;
 	dp83902a_start(dev_addr);
+	initialized=1;
 	return 0;
 }
 
 void eth_halt() {
 
 	PRINTK("### eth_halt\n");
-
-	dp83902a_stop();
+	if(initialized)
+		dp83902a_stop();
+	initialized=0;
 }
 
 int eth_rx() {
-	int j, tmo;
-
-	PRINTK("### eth_rx\n");
-
-	tmo = get_timer (0) + TOUT * CFG_HZ;
-	while(1) {
-		dp83902a_poll();
-		if (nrx > 0) {
-			for(j=0; j<nrx; j++) {
-				NetReceive(&pbuf[j*2000], plen[j]);
-			}
-			nrx = 0;
-			return 1;
-		}
-		if (get_timer (0) >= tmo) {
-			printf("timeout during rx\n");
-			return 0;
-		}
-	}
-	return 0;
+dp83902a_poll();
+return 1;
 }
 
 int eth_send(volatile void *packet, int length) {
@@ -959,5 +944,4 @@ int eth_send(volatile void *packet, int length) {
 	}
 	return 0;
 }
-
 #endif
diff --git a/drivers/ne2000.h b/drivers/ne2000.h
index 2955533..c13d9f0 100644
--- a/drivers/ne2000.h
+++ b/drivers/ne2000.h
@@ -42,7 +42,7 @@ are GPL, so this is, of course, GPL.
  this file might be covered by the GNU General Public License.
 
  Alternative licenses for eCos may be arranged by contacting Red Hat, Inc.
- at http://sources.redhat.com/ecos/ecos-license/ */
+ at http://sources.redhat.com/ecos/ecos-license/
  -------------------------------------------
 ####ECOSGPLCOPYRIGHTEND####
 ####BSDCOPYRIGHTBEGIN####
diff --git a/include/asm-avr32/arch-at32ap7000/clk.h b/include/asm-avr32/arch-at32ap7000/clk.h
deleted file mode 100644
index 7e20d97..0000000
--- a/include/asm-avr32/arch-at32ap7000/clk.h
+++ /dev/null
@@ -1,70 +0,0 @@
-/*
- * Copyright (C) 2006 Atmel Corporation
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-#ifndef __ASM_AVR32_ARCH_CLK_H__
-#define __ASM_AVR32_ARCH_CLK_H__
-
-#ifdef CONFIG_PLL
-#define MAIN_CLK_RATE ((CFG_OSC0_HZ / CFG_PLL0_DIV) * CFG_PLL0_MUL)
-#else
-#define MAIN_CLK_RATE (CFG_OSC0_HZ)
-#endif
-
-static inline unsigned long get_cpu_clk_rate(void)
-{
-	return MAIN_CLK_RATE >> CFG_CLKDIV_CPU;
-}
-static inline unsigned long get_hsb_clk_rate(void)
-{
-	return MAIN_CLK_RATE >> CFG_CLKDIV_HSB;
-}
-static inline unsigned long get_pba_clk_rate(void)
-{
-	return MAIN_CLK_RATE >> CFG_CLKDIV_PBA;
-}
-static inline unsigned long get_pbb_clk_rate(void)
-{
-	return MAIN_CLK_RATE >> CFG_CLKDIV_PBB;
-}
-
-/* Accessors for specific devices. More will be added as needed. */
-static inline unsigned long get_sdram_clk_rate(void)
-{
-	return get_hsb_clk_rate();
-}
-static inline unsigned long get_usart_clk_rate(unsigned int dev_id)
-{
-	return get_pba_clk_rate();
-}
-static inline unsigned long get_macb_pclk_rate(unsigned int dev_id)
-{
-	return get_pbb_clk_rate();
-}
-static inline unsigned long get_macb_hclk_rate(unsigned int dev_id)
-{
-	return get_hsb_clk_rate();
-}
-static inline unsigned long get_mci_clk_rate(void)
-{
-	return get_pbb_clk_rate();
-}
-
-#endif /* __ASM_AVR32_ARCH_CLK_H__ */
diff --git a/include/asm-avr32/arch-at32ap7000/gpio.h b/include/asm-avr32/arch-at32ap7000/gpio.h
deleted file mode 100644
index e4812d4..0000000
--- a/include/asm-avr32/arch-at32ap7000/gpio.h
+++ /dev/null
@@ -1,212 +0,0 @@
-/*
- * Copyright (C) 2006 Atmel Corporation
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-#ifndef __ASM_AVR32_ARCH_GPIO_H__
-#define __ASM_AVR32_ARCH_GPIO_H__
-
-#include <asm/arch/memory-map.h>
-
-#define NR_GPIO_CONTROLLERS	5
-
-/*
- * Pin numbers identifying specific GPIO pins on the chip.
- */
-#define GPIO_PIOA_BASE	(0)
-#define GPIO_PIN_PA0	(GPIO_PIOA_BASE +  0)
-#define GPIO_PIN_PA1	(GPIO_PIOA_BASE +  1)
-#define GPIO_PIN_PA2	(GPIO_PIOA_BASE +  2)
-#define GPIO_PIN_PA3	(GPIO_PIOA_BASE +  3)
-#define GPIO_PIN_PA4	(GPIO_PIOA_BASE +  4)
-#define GPIO_PIN_PA5	(GPIO_PIOA_BASE +  5)
-#define GPIO_PIN_PA6	(GPIO_PIOA_BASE +  6)
-#define GPIO_PIN_PA7	(GPIO_PIOA_BASE +  7)
-#define GPIO_PIN_PA8	(GPIO_PIOA_BASE +  8)
-#define GPIO_PIN_PA9	(GPIO_PIOA_BASE +  9)
-#define GPIO_PIN_PA10	(GPIO_PIOA_BASE + 10)
-#define GPIO_PIN_PA11	(GPIO_PIOA_BASE + 11)
-#define GPIO_PIN_PA12	(GPIO_PIOA_BASE + 12)
-#define GPIO_PIN_PA13	(GPIO_PIOA_BASE + 13)
-#define GPIO_PIN_PA14	(GPIO_PIOA_BASE + 14)
-#define GPIO_PIN_PA15	(GPIO_PIOA_BASE + 15)
-#define GPIO_PIN_PA16	(GPIO_PIOA_BASE + 16)
-#define GPIO_PIN_PA17	(GPIO_PIOA_BASE + 17)
-#define GPIO_PIN_PA18	(GPIO_PIOA_BASE + 18)
-#define GPIO_PIN_PA19	(GPIO_PIOA_BASE + 19)
-#define GPIO_PIN_PA20	(GPIO_PIOA_BASE + 20)
-#define GPIO_PIN_PA21	(GPIO_PIOA_BASE + 21)
-#define GPIO_PIN_PA22	(GPIO_PIOA_BASE + 22)
-#define GPIO_PIN_PA23	(GPIO_PIOA_BASE + 23)
-#define GPIO_PIN_PA24	(GPIO_PIOA_BASE + 24)
-#define GPIO_PIN_PA25	(GPIO_PIOA_BASE + 25)
-#define GPIO_PIN_PA26	(GPIO_PIOA_BASE + 26)
-#define GPIO_PIN_PA27	(GPIO_PIOA_BASE + 27)
-#define GPIO_PIN_PA28	(GPIO_PIOA_BASE + 28)
-#define GPIO_PIN_PA29	(GPIO_PIOA_BASE + 29)
-#define GPIO_PIN_PA30	(GPIO_PIOA_BASE + 30)
-#define GPIO_PIN_PA31	(GPIO_PIOA_BASE + 31)
-
-#define GPIO_PIOB_BASE	(GPIO_PIOA_BASE + 32)
-#define GPIO_PIN_PB0	(GPIO_PIOB_BASE +  0)
-#define GPIO_PIN_PB1	(GPIO_PIOB_BASE +  1)
-#define GPIO_PIN_PB2	(GPIO_PIOB_BASE +  2)
-#define GPIO_PIN_PB3	(GPIO_PIOB_BASE +  3)
-#define GPIO_PIN_PB4	(GPIO_PIOB_BASE +  4)
-#define GPIO_PIN_PB5	(GPIO_PIOB_BASE +  5)
-#define GPIO_PIN_PB6	(GPIO_PIOB_BASE +  6)
-#define GPIO_PIN_PB7	(GPIO_PIOB_BASE +  7)
-#define GPIO_PIN_PB8	(GPIO_PIOB_BASE +  8)
-#define GPIO_PIN_PB9	(GPIO_PIOB_BASE +  9)
-#define GPIO_PIN_PB10	(GPIO_PIOB_BASE + 10)
-#define GPIO_PIN_PB11	(GPIO_PIOB_BASE + 11)
-#define GPIO_PIN_PB12	(GPIO_PIOB_BASE + 12)
-#define GPIO_PIN_PB13	(GPIO_PIOB_BASE + 13)
-#define GPIO_PIN_PB14	(GPIO_PIOB_BASE + 14)
-#define GPIO_PIN_PB15	(GPIO_PIOB_BASE + 15)
-#define GPIO_PIN_PB16	(GPIO_PIOB_BASE + 16)
-#define GPIO_PIN_PB17	(GPIO_PIOB_BASE + 17)
-#define GPIO_PIN_PB18	(GPIO_PIOB_BASE + 18)
-#define GPIO_PIN_PB19	(GPIO_PIOB_BASE + 19)
-#define GPIO_PIN_PB20	(GPIO_PIOB_BASE + 20)
-#define GPIO_PIN_PB21	(GPIO_PIOB_BASE + 21)
-#define GPIO_PIN_PB22	(GPIO_PIOB_BASE + 22)
-#define GPIO_PIN_PB23	(GPIO_PIOB_BASE + 23)
-#define GPIO_PIN_PB24	(GPIO_PIOB_BASE + 24)
-#define GPIO_PIN_PB25	(GPIO_PIOB_BASE + 25)
-#define GPIO_PIN_PB26	(GPIO_PIOB_BASE + 26)
-#define GPIO_PIN_PB27	(GPIO_PIOB_BASE + 27)
-#define GPIO_PIN_PB28	(GPIO_PIOB_BASE + 28)
-#define GPIO_PIN_PB29	(GPIO_PIOB_BASE + 29)
-#define GPIO_PIN_PB30	(GPIO_PIOB_BASE + 30)
-
-#define GPIO_PIOC_BASE	(GPIO_PIOB_BASE + 32)
-#define GPIO_PIN_PC0	(GPIO_PIOC_BASE +  0)
-#define GPIO_PIN_PC1	(GPIO_PIOC_BASE +  1)
-#define GPIO_PIN_PC2	(GPIO_PIOC_BASE +  2)
-#define GPIO_PIN_PC3	(GPIO_PIOC_BASE +  3)
-#define GPIO_PIN_PC4	(GPIO_PIOC_BASE +  4)
-#define GPIO_PIN_PC5	(GPIO_PIOC_BASE +  5)
-#define GPIO_PIN_PC6	(GPIO_PIOC_BASE +  6)
-#define GPIO_PIN_PC7	(GPIO_PIOC_BASE +  7)
-#define GPIO_PIN_PC8	(GPIO_PIOC_BASE +  8)
-#define GPIO_PIN_PC9	(GPIO_PIOC_BASE +  9)
-#define GPIO_PIN_PC10	(GPIO_PIOC_BASE + 10)
-#define GPIO_PIN_PC11	(GPIO_PIOC_BASE + 11)
-#define GPIO_PIN_PC12	(GPIO_PIOC_BASE + 12)
-#define GPIO_PIN_PC13	(GPIO_PIOC_BASE + 13)
-#define GPIO_PIN_PC14	(GPIO_PIOC_BASE + 14)
-#define GPIO_PIN_PC15	(GPIO_PIOC_BASE + 15)
-#define GPIO_PIN_PC16	(GPIO_PIOC_BASE + 16)
-#define GPIO_PIN_PC17	(GPIO_PIOC_BASE + 17)
-#define GPIO_PIN_PC18	(GPIO_PIOC_BASE + 18)
-#define GPIO_PIN_PC19	(GPIO_PIOC_BASE + 19)
-#define GPIO_PIN_PC20	(GPIO_PIOC_BASE + 20)
-#define GPIO_PIN_PC21	(GPIO_PIOC_BASE + 21)
-#define GPIO_PIN_PC22	(GPIO_PIOC_BASE + 22)
-#define GPIO_PIN_PC23	(GPIO_PIOC_BASE + 23)
-#define GPIO_PIN_PC24	(GPIO_PIOC_BASE + 24)
-#define GPIO_PIN_PC25	(GPIO_PIOC_BASE + 25)
-#define GPIO_PIN_PC26	(GPIO_PIOC_BASE + 26)
-#define GPIO_PIN_PC27	(GPIO_PIOC_BASE + 27)
-#define GPIO_PIN_PC28	(GPIO_PIOC_BASE + 28)
-#define GPIO_PIN_PC29	(GPIO_PIOC_BASE + 29)
-#define GPIO_PIN_PC30	(GPIO_PIOC_BASE + 30)
-#define GPIO_PIN_PC31	(GPIO_PIOC_BASE + 31)
-
-#define GPIO_PIOD_BASE	(GPIO_PIOC_BASE + 32)
-#define GPIO_PIN_PD0	(GPIO_PIOD_BASE +  0)
-#define GPIO_PIN_PD1	(GPIO_PIOD_BASE +  1)
-#define GPIO_PIN_PD2	(GPIO_PIOD_BASE +  2)
-#define GPIO_PIN_PD3	(GPIO_PIOD_BASE +  3)
-#define GPIO_PIN_PD4	(GPIO_PIOD_BASE +  4)
-#define GPIO_PIN_PD5	(GPIO_PIOD_BASE +  5)
-#define GPIO_PIN_PD6	(GPIO_PIOD_BASE +  6)
-#define GPIO_PIN_PD7	(GPIO_PIOD_BASE +  7)
-#define GPIO_PIN_PD8	(GPIO_PIOD_BASE +  8)
-#define GPIO_PIN_PD9	(GPIO_PIOD_BASE +  9)
-#define GPIO_PIN_PD10	(GPIO_PIOD_BASE + 10)
-#define GPIO_PIN_PD11	(GPIO_PIOD_BASE + 11)
-#define GPIO_PIN_PD12	(GPIO_PIOD_BASE + 12)
-#define GPIO_PIN_PD13	(GPIO_PIOD_BASE + 13)
-#define GPIO_PIN_PD14	(GPIO_PIOD_BASE + 14)
-#define GPIO_PIN_PD15	(GPIO_PIOD_BASE + 15)
-#define GPIO_PIN_PD16	(GPIO_PIOD_BASE + 16)
-#define GPIO_PIN_PD17	(GPIO_PIOD_BASE + 17)
-
-#define GPIO_PIOE_BASE	(GPIO_PIOD_BASE + 32)
-#define GPIO_PIN_PE0	(GPIO_PIOE_BASE +  0)
-#define GPIO_PIN_PE1	(GPIO_PIOE_BASE +  1)
-#define GPIO_PIN_PE2	(GPIO_PIOE_BASE +  2)
-#define GPIO_PIN_PE3	(GPIO_PIOE_BASE +  3)
-#define GPIO_PIN_PE4	(GPIO_PIOE_BASE +  4)
-#define GPIO_PIN_PE5	(GPIO_PIOE_BASE +  5)
-#define GPIO_PIN_PE6	(GPIO_PIOE_BASE +  6)
-#define GPIO_PIN_PE7	(GPIO_PIOE_BASE +  7)
-#define GPIO_PIN_PE8	(GPIO_PIOE_BASE +  8)
-#define GPIO_PIN_PE9	(GPIO_PIOE_BASE +  9)
-#define GPIO_PIN_PE10	(GPIO_PIOE_BASE + 10)
-#define GPIO_PIN_PE11	(GPIO_PIOE_BASE + 11)
-#define GPIO_PIN_PE12	(GPIO_PIOE_BASE + 12)
-#define GPIO_PIN_PE13	(GPIO_PIOE_BASE + 13)
-#define GPIO_PIN_PE14	(GPIO_PIOE_BASE + 14)
-#define GPIO_PIN_PE15	(GPIO_PIOE_BASE + 15)
-#define GPIO_PIN_PE16	(GPIO_PIOE_BASE + 16)
-#define GPIO_PIN_PE17	(GPIO_PIOE_BASE + 17)
-#define GPIO_PIN_PE18	(GPIO_PIOE_BASE + 18)
-#define GPIO_PIN_PE19	(GPIO_PIOE_BASE + 19)
-#define GPIO_PIN_PE20	(GPIO_PIOE_BASE + 20)
-#define GPIO_PIN_PE21	(GPIO_PIOE_BASE + 21)
-#define GPIO_PIN_PE22	(GPIO_PIOE_BASE + 22)
-#define GPIO_PIN_PE23	(GPIO_PIOE_BASE + 23)
-#define GPIO_PIN_PE24	(GPIO_PIOE_BASE + 24)
-#define GPIO_PIN_PE25	(GPIO_PIOE_BASE + 25)
-#define GPIO_PIN_PE26	(GPIO_PIOE_BASE + 26)
-
-static inline void *gpio_pin_to_addr(unsigned int pin)
-{
-	switch (pin >> 5) {
-	case 0:
-		return (void *)PIOA_BASE;
-	case 1:
-		return (void *)PIOB_BASE;
-	case 2:
-		return (void *)PIOC_BASE;
-	case 3:
-		return (void *)PIOD_BASE;
-	case 4:
-		return (void *)PIOE_BASE;
-	default:
-		return NULL;
-	}
-}
-
-void gpio_select_periph_A(unsigned int pin, int use_pullup);
-void gpio_select_periph_B(unsigned int pin, int use_pullup);
-
-void gpio_enable_ebi(void);
-void gpio_enable_usart0(void);
-void gpio_enable_usart1(void);
-void gpio_enable_usart2(void);
-void gpio_enable_usart3(void);
-void gpio_enable_macb0(void);
-void gpio_enable_macb1(void);
-void gpio_enable_mmci(void);
-
-#endif /* __ASM_AVR32_ARCH_GPIO_H__ */
diff --git a/include/asm-avr32/arch-at32ap7000/hmatrix2.h b/include/asm-avr32/arch-at32ap7000/hmatrix2.h
deleted file mode 100644
index b0e787a..0000000
--- a/include/asm-avr32/arch-at32ap7000/hmatrix2.h
+++ /dev/null
@@ -1,232 +0,0 @@
-/*
- * Register definition for the High-speed Bus Matrix
- */
-#ifndef __ASM_AVR32_HMATRIX2_H__
-#define __ASM_AVR32_HMATRIX2_H__
-
-/* HMATRIX2 register offsets */
-#define HMATRIX2_MCFG0				0x0000
-#define HMATRIX2_MCFG1				0x0004
-#define HMATRIX2_MCFG2				0x0008
-#define HMATRIX2_MCFG3				0x000c
-#define HMATRIX2_MCFG4				0x0010
-#define HMATRIX2_MCFG5				0x0014
-#define HMATRIX2_MCFG6				0x0018
-#define HMATRIX2_MCFG7				0x001c
-#define HMATRIX2_MCFG8				0x0020
-#define HMATRIX2_MCFG9				0x0024
-#define HMATRIX2_MCFG10				0x0028
-#define HMATRIX2_MCFG11				0x002c
-#define HMATRIX2_MCFG12				0x0030
-#define HMATRIX2_MCFG13				0x0034
-#define HMATRIX2_MCFG14				0x0038
-#define HMATRIX2_MCFG15				0x003c
-#define HMATRIX2_SCFG0				0x0040
-#define HMATRIX2_SCFG1				0x0044
-#define HMATRIX2_SCFG2				0x0048
-#define HMATRIX2_SCFG3				0x004c
-#define HMATRIX2_SCFG4				0x0050
-#define HMATRIX2_SCFG5				0x0054
-#define HMATRIX2_SCFG6				0x0058
-#define HMATRIX2_SCFG7				0x005c
-#define HMATRIX2_SCFG8				0x0060
-#define HMATRIX2_SCFG9				0x0064
-#define HMATRIX2_SCFG10				0x0068
-#define HMATRIX2_SCFG11				0x006c
-#define HMATRIX2_SCFG12				0x0070
-#define HMATRIX2_SCFG13				0x0074
-#define HMATRIX2_SCFG14				0x0078
-#define HMATRIX2_SCFG15				0x007c
-#define HMATRIX2_PRAS0				0x0080
-#define HMATRIX2_PRBS0				0x0084
-#define HMATRIX2_PRAS1				0x0088
-#define HMATRIX2_PRBS1				0x008c
-#define HMATRIX2_PRAS2				0x0090
-#define HMATRIX2_PRBS2				0x0094
-#define HMATRIX2_PRAS3				0x0098
-#define HMATRIX2_PRBS3				0x009c
-#define HMATRIX2_PRAS4				0x00a0
-#define HMATRIX2_PRBS4				0x00a4
-#define HMATRIX2_PRAS5				0x00a8
-#define HMATRIX2_PRBS5				0x00ac
-#define HMATRIX2_PRAS6				0x00b0
-#define HMATRIX2_PRBS6				0x00b4
-#define HMATRIX2_PRAS7				0x00b8
-#define HMATRIX2_PRBS7				0x00bc
-#define HMATRIX2_PRAS8				0x00c0
-#define HMATRIX2_PRBS8				0x00c4
-#define HMATRIX2_PRAS9				0x00c8
-#define HMATRIX2_PRBS9				0x00cc
-#define HMATRIX2_PRAS10				0x00d0
-#define HMATRIX2_PRBS10				0x00d4
-#define HMATRIX2_PRAS11				0x00d8
-#define HMATRIX2_PRBS11				0x00dc
-#define HMATRIX2_PRAS12				0x00e0
-#define HMATRIX2_PRBS12				0x00e4
-#define HMATRIX2_PRAS13				0x00e8
-#define HMATRIX2_PRBS13				0x00ec
-#define HMATRIX2_PRAS14				0x00f0
-#define HMATRIX2_PRBS14				0x00f4
-#define HMATRIX2_PRAS15				0x00f8
-#define HMATRIX2_PRBS15				0x00fc
-#define HMATRIX2_MRCR				0x0100
-#define HMATRIX2_SFR0				0x0110
-#define HMATRIX2_SFR1				0x0114
-#define HMATRIX2_SFR2				0x0118
-#define HMATRIX2_SFR3				0x011c
-#define HMATRIX2_SFR4				0x0120
-#define HMATRIX2_SFR5				0x0124
-#define HMATRIX2_SFR6				0x0128
-#define HMATRIX2_SFR7				0x012c
-#define HMATRIX2_SFR8				0x0130
-#define HMATRIX2_SFR9				0x0134
-#define HMATRIX2_SFR10				0x0138
-#define HMATRIX2_SFR11				0x013c
-#define HMATRIX2_SFR12				0x0140
-#define HMATRIX2_SFR13				0x0144
-#define HMATRIX2_SFR14				0x0148
-#define HMATRIX2_SFR15				0x014c
-#define HMATRIX2_VERSION			0x01fc
-
-/* Bitfields in MCFG0 */
-#define HMATRIX2_ULBT_OFFSET			0
-#define HMATRIX2_ULBT_SIZE			3
-
-/* Bitfields in SCFG0 */
-#define HMATRIX2_SLOT_CYCLE_OFFSET		0
-#define HMATRIX2_SLOT_CYCLE_SIZE		8
-#define HMATRIX2_DEFMSTR_TYPE_OFFSET		16
-#define HMATRIX2_DEFMSTR_TYPE_SIZE		2
-#define HMATRIX2_FIXED_DEFMSTR_OFFSET		18
-#define HMATRIX2_FIXED_DEFMSTR_SIZE		4
-#define HMATRIX2_ARBT_OFFSET			24
-#define HMATRIX2_ARBT_SIZE			2
-
-/* Bitfields in PRAS0 */
-#define HMATRIX2_M0PR_OFFSET			0
-#define HMATRIX2_M0PR_SIZE			4
-#define HMATRIX2_M1PR_OFFSET			4
-#define HMATRIX2_M1PR_SIZE			4
-#define HMATRIX2_M2PR_OFFSET			8
-#define HMATRIX2_M2PR_SIZE			4
-#define HMATRIX2_M3PR_OFFSET			12
-#define HMATRIX2_M3PR_SIZE			4
-#define HMATRIX2_M4PR_OFFSET			16
-#define HMATRIX2_M4PR_SIZE			4
-#define HMATRIX2_M5PR_OFFSET			20
-#define HMATRIX2_M5PR_SIZE			4
-#define HMATRIX2_M6PR_OFFSET			24
-#define HMATRIX2_M6PR_SIZE			4
-#define HMATRIX2_M7PR_OFFSET			28
-#define HMATRIX2_M7PR_SIZE			4
-
-/* Bitfields in PRBS0 */
-#define HMATRIX2_M8PR_OFFSET			0
-#define HMATRIX2_M8PR_SIZE			4
-#define HMATRIX2_M9PR_OFFSET			4
-#define HMATRIX2_M9PR_SIZE			4
-#define HMATRIX2_M10PR_OFFSET			8
-#define HMATRIX2_M10PR_SIZE			4
-#define HMATRIX2_M11PR_OFFSET			12
-#define HMATRIX2_M11PR_SIZE			4
-#define HMATRIX2_M12PR_OFFSET			16
-#define HMATRIX2_M12PR_SIZE			4
-#define HMATRIX2_M13PR_OFFSET			20
-#define HMATRIX2_M13PR_SIZE			4
-#define HMATRIX2_M14PR_OFFSET			24
-#define HMATRIX2_M14PR_SIZE			4
-#define HMATRIX2_M15PR_OFFSET			28
-#define HMATRIX2_M15PR_SIZE			4
-
-/* Bitfields in MRCR */
-#define HMATRIX2_RBC0_OFFSET			0
-#define HMATRIX2_RBC0_SIZE			1
-#define HMATRIX2_RBC1_OFFSET			1
-#define HMATRIX2_RBC1_SIZE			1
-#define HMATRIX2_RBC2_OFFSET			2
-#define HMATRIX2_RBC2_SIZE			1
-#define HMATRIX2_RBC3_OFFSET			3
-#define HMATRIX2_RBC3_SIZE			1
-#define HMATRIX2_RBC4_OFFSET			4
-#define HMATRIX2_RBC4_SIZE			1
-#define HMATRIX2_RBC5_OFFSET			5
-#define HMATRIX2_RBC5_SIZE			1
-#define HMATRIX2_RBC6_OFFSET			6
-#define HMATRIX2_RBC6_SIZE			1
-#define HMATRIX2_RBC7_OFFSET			7
-#define HMATRIX2_RBC7_SIZE			1
-#define HMATRIX2_RBC8_OFFSET			8
-#define HMATRIX2_RBC8_SIZE			1
-#define HMATRIX2_RBC9_OFFSET			9
-#define HMATRIX2_RBC9_SIZE			1
-#define HMATRIX2_RBC10_OFFSET			10
-#define HMATRIX2_RBC10_SIZE			1
-#define HMATRIX2_RBC11_OFFSET			11
-#define HMATRIX2_RBC11_SIZE			1
-#define HMATRIX2_RBC12_OFFSET			12
-#define HMATRIX2_RBC12_SIZE			1
-#define HMATRIX2_RBC13_OFFSET			13
-#define HMATRIX2_RBC13_SIZE			1
-#define HMATRIX2_RBC14_OFFSET			14
-#define HMATRIX2_RBC14_SIZE			1
-#define HMATRIX2_RBC15_OFFSET			15
-#define HMATRIX2_RBC15_SIZE			1
-
-/* Bitfields in SFR0 */
-#define HMATRIX2_SFR_OFFSET			0
-#define HMATRIX2_SFR_SIZE			32
-
-/* Bitfields in SFR4 */
-#define HMATRIX2_CS1A_OFFSET			1
-#define HMATRIX2_CS1A_SIZE			1
-#define HMATRIX2_CS3A_OFFSET			3
-#define HMATRIX2_CS3A_SIZE			1
-#define HMATRIX2_CS4A_OFFSET			4
-#define HMATRIX2_CS4A_SIZE			1
-#define HMATRIX2_CS5A_OFFSET			5
-#define HMATRIX2_CS5A_SIZE			1
-#define HMATRIX2_DBPUC_OFFSET			8
-#define HMATRIX2_DBPUC_SIZE			1
-
-/* Bitfields in VERSION */
-#define HMATRIX2_VERSION_OFFSET			0
-#define HMATRIX2_VERSION_SIZE			12
-#define HMATRIX2_MFN_OFFSET			16
-#define HMATRIX2_MFN_SIZE			3
-
-/* Constants for ULBT */
-#define HMATRIX2_ULBT_INFINITE			0
-#define HMATRIX2_ULBT_SINGLE			1
-#define HMATRIX2_ULBT_FOUR_BEAT			2
-#define HMATRIX2_ULBT_SIXTEEN_BEAT		4
-
-/* Constants for DEFMSTR_TYPE */
-#define HMATRIX2_DEFMSTR_TYPE_NO_DEFAULT	0
-#define HMATRIX2_DEFMSTR_TYPE_LAST_DEFAULT	1
-#define HMATRIX2_DEFMSTR_TYPE_FIXED_DEFAULT	2
-
-/* Constants for ARBT */
-#define HMATRIX2_ARBT_ROUND_ROBIN		0
-#define HMATRIX2_ARBT_FIXED_PRIORITY		1
-
-/* Bit manipulation macros */
-#define HMATRIX2_BIT(name)					\
-	(1 << HMATRIX2_##name##_OFFSET)
-#define HMATRIX2_BF(name,value)					\
-	(((value) & ((1 << HMATRIX2_##name##_SIZE) - 1))	\
-	 << HMATRIX2_##name##_OFFSET)
-#define HMATRIX2_BFEXT(name,value)				\
-	(((value) >> HMATRIX2_##name##_OFFSET)			\
-	 & ((1 << HMATRIX2_##name##_SIZE) - 1))
-#define HMATRIX2_BFINS(name,value,old)				\
-	(((old) & ~(((1 << HMATRIX2_##name##_SIZE) - 1)		\
-		    << HMATRIX2_##name##_OFFSET))		\
-	 | HMATRIX2_BF(name,value))
-
-/* Register access macros */
-#define hmatrix2_readl(reg)					\
-	readl((void *)HMATRIX_BASE + HMATRIX2_##reg)
-#define hmatrix2_writel(reg,value)				\
-	writel((value), (void *)HMATRIX_BASE + HMATRIX2_##reg)
-
-#endif /* __ASM_AVR32_HMATRIX2_H__ */
diff --git a/include/asm-avr32/arch-at32ap7000/memory-map.h b/include/asm-avr32/arch-at32ap7000/memory-map.h
deleted file mode 100644
index 5513e88..0000000
--- a/include/asm-avr32/arch-at32ap7000/memory-map.h
+++ /dev/null
@@ -1,66 +0,0 @@
-/*
- * Copyright (C) 2005-2006 Atmel Corporation
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-#ifndef __AT32AP7000_MEMORY_MAP_H__
-#define __AT32AP7000_MEMORY_MAP_H__
-
-/* Devices on the High Speed Bus (HSB) */
-#define LCDC_BASE				0xFF000000
-#define DMAC_BASE				0xFF200000
-#define USB_FIFO				0xFF300000
-
-/* Devices on Peripheral Bus A (PBA) */
-#define SPI0_BASE				0xFFE00000
-#define SPI1_BASE				0xFFE00400
-#define TWI_BASE				0xFFE00800
-#define USART0_BASE				0xFFE00C00
-#define USART1_BASE				0xFFE01000
-#define USART2_BASE				0xFFE01400
-#define USART3_BASE				0xFFE01800
-#define SSC0_BASE				0xFFE01C00
-#define SSC1_BASE				0xFFE02000
-#define SSC2_BASE				0xFFE02400
-#define PIOA_BASE				0xFFE02800
-#define PIOB_BASE				0xFFE02C00
-#define PIOC_BASE				0xFFE03000
-#define PIOD_BASE				0xFFE03400
-#define PIOE_BASE				0xFFE03800
-#define PSIF_BASE				0xFFE03C00
-
-/* Devices on Peripheral Bus B (PBB) */
-#define SM_BASE					0xFFF00000
-#define INTC_BASE				0xFFF00400
-#define HMATRIX_BASE				0xFFF00800
-#define TIMER0_BASE				0xFFF00C00
-#define TIMER1_BASE				0xFFF01000
-#define PWM_BASE				0xFFF01400
-#define MACB0_BASE				0xFFF01800
-#define MACB1_BASE				0xFFF01C00
-#define DAC_BASE				0xFFF02000
-#define MMCI_BASE				0xFFF02400
-#define AUDIOC_BASE				0xFFF02800
-#define HISI_BASE				0xFFF02C00
-#define USB_BASE				0xFFF03000
-#define HSMC_BASE				0xFFF03400
-#define HSDRAMC_BASE				0xFFF03800
-#define ECC_BASE				0xFFF03C00
-
-#endif /* __AT32AP7000_MEMORY_MAP_H__ */
diff --git a/include/asm-avr32/arch-at32ap7000/mmc.h b/include/asm-avr32/arch-at32ap7000/mmc.h
deleted file mode 100644
index fcfbbb3..0000000
--- a/include/asm-avr32/arch-at32ap7000/mmc.h
+++ /dev/null
@@ -1,96 +0,0 @@
-/*
- * Copyright (C) 2004-2006 Atmel Corporation
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-#ifndef __ASM_AVR32_MMC_H
-#define __ASM_AVR32_MMC_H
-
-struct mmc_cid {
-	unsigned long psn;
-	unsigned short oid;
-	unsigned char mid;
-	unsigned char prv;
-	unsigned char mdt;
-	char pnm[7];
-};
-
-struct mmc_csd
-{
-	u8	csd_structure:2,
-		spec_vers:4,
-		rsvd1:2;
-	u8	taac;
-	u8	nsac;
-	u8	tran_speed;
-	u16	ccc:12,
-		read_bl_len:4;
-	u64	read_bl_partial:1,
-		write_blk_misalign:1,
-		read_blk_misalign:1,
-		dsr_imp:1,
-		rsvd2:2,
-		c_size:12,
-		vdd_r_curr_min:3,
-		vdd_r_curr_max:3,
-		vdd_w_curr_min:3,
-		vdd_w_curr_max:3,
-		c_size_mult:3,
-		sector_size:5,
-		erase_grp_size:5,
-		wp_grp_size:5,
-		wp_grp_enable:1,
-		default_ecc:2,
-		r2w_factor:3,
-		write_bl_len:4,
-		write_bl_partial:1,
-		rsvd3:5;
-	u8	file_format_grp:1,
-		copy:1,
-		perm_write_protect:1,
-		tmp_write_protect:1,
-		file_format:2,
-		ecc:2;
-	u8	crc:7;
-	u8	one:1;
-};
-
-/* MMC Command numbers */
-#define MMC_CMD_GO_IDLE_STATE		0
-#define MMC_CMD_SEND_OP_COND		1
-#define MMC_CMD_ALL_SEND_CID 		2
-#define MMC_CMD_SET_RELATIVE_ADDR	3
-#define MMC_CMD_SD_SEND_RELATIVE_ADDR	3
-#define MMC_CMD_SET_DSR			4
-#define MMC_CMD_SELECT_CARD		7
-#define MMC_CMD_SEND_CSD 		9
-#define MMC_CMD_SEND_CID 		10
-#define MMC_CMD_SEND_STATUS		13
-#define MMC_CMD_SET_BLOCKLEN		16
-#define MMC_CMD_READ_SINGLE_BLOCK	17
-#define MMC_CMD_READ_MULTIPLE_BLOCK	18
-#define MMC_CMD_WRITE_BLOCK		24
-#define MMC_CMD_APP_CMD			55
-
-#define MMC_ACMD_SD_SEND_OP_COND	41
-
-#define R1_ILLEGAL_COMMAND		(1 << 22)
-#define R1_APP_CMD			(1 << 5)
-
-#endif /* __ASM_AVR32_MMC_H */
diff --git a/include/asm-avr32/arch-at32ap700x/chip-features.h b/include/asm-avr32/arch-at32ap700x/chip-features.h
new file mode 100644
index 0000000..29b1fd6
--- /dev/null
+++ b/include/asm-avr32/arch-at32ap700x/chip-features.h
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2007 Atmel Corporation
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#ifndef __ASM_AVR32_ARCH_CHIP_FEATURES_H__
+#define __ASM_AVR32_ARCH_CHIP_FEATURES_H__
+
+/* Currently, all the AP700x chips have these */
+#define AT32AP700x_CHIP_HAS_USART
+#define AT32AP700x_CHIP_HAS_MMCI
+
+/* Only AP7000 has ethernet interface */
+#ifdef CONFIG_AT32AP7000
+#define AT32AP700x_CHIP_HAS_MACB
+#endif
+
+#endif /* __ASM_AVR32_ARCH_CHIP_FEATURES_H__ */
diff --git a/include/asm-avr32/arch-at32ap700x/clk.h b/include/asm-avr32/arch-at32ap700x/clk.h
new file mode 100644
index 0000000..ea84c08
--- /dev/null
+++ b/include/asm-avr32/arch-at32ap700x/clk.h
@@ -0,0 +1,78 @@
+/*
+ * Copyright (C) 2006 Atmel Corporation
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#ifndef __ASM_AVR32_ARCH_CLK_H__
+#define __ASM_AVR32_ARCH_CLK_H__
+
+#include <asm/arch/chip-features.h>
+
+#ifdef CONFIG_PLL
+#define MAIN_CLK_RATE ((CFG_OSC0_HZ / CFG_PLL0_DIV) * CFG_PLL0_MUL)
+#else
+#define MAIN_CLK_RATE (CFG_OSC0_HZ)
+#endif
+
+static inline unsigned long get_cpu_clk_rate(void)
+{
+	return MAIN_CLK_RATE >> CFG_CLKDIV_CPU;
+}
+static inline unsigned long get_hsb_clk_rate(void)
+{
+	return MAIN_CLK_RATE >> CFG_CLKDIV_HSB;
+}
+static inline unsigned long get_pba_clk_rate(void)
+{
+	return MAIN_CLK_RATE >> CFG_CLKDIV_PBA;
+}
+static inline unsigned long get_pbb_clk_rate(void)
+{
+	return MAIN_CLK_RATE >> CFG_CLKDIV_PBB;
+}
+
+/* Accessors for specific devices. More will be added as needed. */
+static inline unsigned long get_sdram_clk_rate(void)
+{
+	return get_hsb_clk_rate();
+}
+#ifdef AT32AP700x_CHIP_HAS_USART
+static inline unsigned long get_usart_clk_rate(unsigned int dev_id)
+{
+	return get_pba_clk_rate();
+}
+#endif
+#ifdef AT32AP700x_CHIP_HAS_USART
+static inline unsigned long get_macb_pclk_rate(unsigned int dev_id)
+{
+	return get_pbb_clk_rate();
+}
+static inline unsigned long get_macb_hclk_rate(unsigned int dev_id)
+{
+	return get_hsb_clk_rate();
+}
+#endif
+#ifdef AT32AP700x_CHIP_HAS_MMCI
+static inline unsigned long get_mci_clk_rate(void)
+{
+	return get_pbb_clk_rate();
+}
+#endif
+
+#endif /* __ASM_AVR32_ARCH_CLK_H__ */
diff --git a/include/asm-avr32/arch-at32ap700x/gpio.h b/include/asm-avr32/arch-at32ap700x/gpio.h
new file mode 100644
index 0000000..b10a3e4
--- /dev/null
+++ b/include/asm-avr32/arch-at32ap700x/gpio.h
@@ -0,0 +1,220 @@
+/*
+ * Copyright (C) 2006 Atmel Corporation
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#ifndef __ASM_AVR32_ARCH_GPIO_H__
+#define __ASM_AVR32_ARCH_GPIO_H__
+
+#include <asm/arch/chip-features.h>
+#include <asm/arch/memory-map.h>
+
+#define NR_GPIO_CONTROLLERS	5
+
+/*
+ * Pin numbers identifying specific GPIO pins on the chip.
+ */
+#define GPIO_PIOA_BASE	(0)
+#define GPIO_PIN_PA0	(GPIO_PIOA_BASE +  0)
+#define GPIO_PIN_PA1	(GPIO_PIOA_BASE +  1)
+#define GPIO_PIN_PA2	(GPIO_PIOA_BASE +  2)
+#define GPIO_PIN_PA3	(GPIO_PIOA_BASE +  3)
+#define GPIO_PIN_PA4	(GPIO_PIOA_BASE +  4)
+#define GPIO_PIN_PA5	(GPIO_PIOA_BASE +  5)
+#define GPIO_PIN_PA6	(GPIO_PIOA_BASE +  6)
+#define GPIO_PIN_PA7	(GPIO_PIOA_BASE +  7)
+#define GPIO_PIN_PA8	(GPIO_PIOA_BASE +  8)
+#define GPIO_PIN_PA9	(GPIO_PIOA_BASE +  9)
+#define GPIO_PIN_PA10	(GPIO_PIOA_BASE + 10)
+#define GPIO_PIN_PA11	(GPIO_PIOA_BASE + 11)
+#define GPIO_PIN_PA12	(GPIO_PIOA_BASE + 12)
+#define GPIO_PIN_PA13	(GPIO_PIOA_BASE + 13)
+#define GPIO_PIN_PA14	(GPIO_PIOA_BASE + 14)
+#define GPIO_PIN_PA15	(GPIO_PIOA_BASE + 15)
+#define GPIO_PIN_PA16	(GPIO_PIOA_BASE + 16)
+#define GPIO_PIN_PA17	(GPIO_PIOA_BASE + 17)
+#define GPIO_PIN_PA18	(GPIO_PIOA_BASE + 18)
+#define GPIO_PIN_PA19	(GPIO_PIOA_BASE + 19)
+#define GPIO_PIN_PA20	(GPIO_PIOA_BASE + 20)
+#define GPIO_PIN_PA21	(GPIO_PIOA_BASE + 21)
+#define GPIO_PIN_PA22	(GPIO_PIOA_BASE + 22)
+#define GPIO_PIN_PA23	(GPIO_PIOA_BASE + 23)
+#define GPIO_PIN_PA24	(GPIO_PIOA_BASE + 24)
+#define GPIO_PIN_PA25	(GPIO_PIOA_BASE + 25)
+#define GPIO_PIN_PA26	(GPIO_PIOA_BASE + 26)
+#define GPIO_PIN_PA27	(GPIO_PIOA_BASE + 27)
+#define GPIO_PIN_PA28	(GPIO_PIOA_BASE + 28)
+#define GPIO_PIN_PA29	(GPIO_PIOA_BASE + 29)
+#define GPIO_PIN_PA30	(GPIO_PIOA_BASE + 30)
+#define GPIO_PIN_PA31	(GPIO_PIOA_BASE + 31)
+
+#define GPIO_PIOB_BASE	(GPIO_PIOA_BASE + 32)
+#define GPIO_PIN_PB0	(GPIO_PIOB_BASE +  0)
+#define GPIO_PIN_PB1	(GPIO_PIOB_BASE +  1)
+#define GPIO_PIN_PB2	(GPIO_PIOB_BASE +  2)
+#define GPIO_PIN_PB3	(GPIO_PIOB_BASE +  3)
+#define GPIO_PIN_PB4	(GPIO_PIOB_BASE +  4)
+#define GPIO_PIN_PB5	(GPIO_PIOB_BASE +  5)
+#define GPIO_PIN_PB6	(GPIO_PIOB_BASE +  6)
+#define GPIO_PIN_PB7	(GPIO_PIOB_BASE +  7)
+#define GPIO_PIN_PB8	(GPIO_PIOB_BASE +  8)
+#define GPIO_PIN_PB9	(GPIO_PIOB_BASE +  9)
+#define GPIO_PIN_PB10	(GPIO_PIOB_BASE + 10)
+#define GPIO_PIN_PB11	(GPIO_PIOB_BASE + 11)
+#define GPIO_PIN_PB12	(GPIO_PIOB_BASE + 12)
+#define GPIO_PIN_PB13	(GPIO_PIOB_BASE + 13)
+#define GPIO_PIN_PB14	(GPIO_PIOB_BASE + 14)
+#define GPIO_PIN_PB15	(GPIO_PIOB_BASE + 15)
+#define GPIO_PIN_PB16	(GPIO_PIOB_BASE + 16)
+#define GPIO_PIN_PB17	(GPIO_PIOB_BASE + 17)
+#define GPIO_PIN_PB18	(GPIO_PIOB_BASE + 18)
+#define GPIO_PIN_PB19	(GPIO_PIOB_BASE + 19)
+#define GPIO_PIN_PB20	(GPIO_PIOB_BASE + 20)
+#define GPIO_PIN_PB21	(GPIO_PIOB_BASE + 21)
+#define GPIO_PIN_PB22	(GPIO_PIOB_BASE + 22)
+#define GPIO_PIN_PB23	(GPIO_PIOB_BASE + 23)
+#define GPIO_PIN_PB24	(GPIO_PIOB_BASE + 24)
+#define GPIO_PIN_PB25	(GPIO_PIOB_BASE + 25)
+#define GPIO_PIN_PB26	(GPIO_PIOB_BASE + 26)
+#define GPIO_PIN_PB27	(GPIO_PIOB_BASE + 27)
+#define GPIO_PIN_PB28	(GPIO_PIOB_BASE + 28)
+#define GPIO_PIN_PB29	(GPIO_PIOB_BASE + 29)
+#define GPIO_PIN_PB30	(GPIO_PIOB_BASE + 30)
+
+#define GPIO_PIOC_BASE	(GPIO_PIOB_BASE + 32)
+#define GPIO_PIN_PC0	(GPIO_PIOC_BASE +  0)
+#define GPIO_PIN_PC1	(GPIO_PIOC_BASE +  1)
+#define GPIO_PIN_PC2	(GPIO_PIOC_BASE +  2)
+#define GPIO_PIN_PC3	(GPIO_PIOC_BASE +  3)
+#define GPIO_PIN_PC4	(GPIO_PIOC_BASE +  4)
+#define GPIO_PIN_PC5	(GPIO_PIOC_BASE +  5)
+#define GPIO_PIN_PC6	(GPIO_PIOC_BASE +  6)
+#define GPIO_PIN_PC7	(GPIO_PIOC_BASE +  7)
+#define GPIO_PIN_PC8	(GPIO_PIOC_BASE +  8)
+#define GPIO_PIN_PC9	(GPIO_PIOC_BASE +  9)
+#define GPIO_PIN_PC10	(GPIO_PIOC_BASE + 10)
+#define GPIO_PIN_PC11	(GPIO_PIOC_BASE + 11)
+#define GPIO_PIN_PC12	(GPIO_PIOC_BASE + 12)
+#define GPIO_PIN_PC13	(GPIO_PIOC_BASE + 13)
+#define GPIO_PIN_PC14	(GPIO_PIOC_BASE + 14)
+#define GPIO_PIN_PC15	(GPIO_PIOC_BASE + 15)
+#define GPIO_PIN_PC16	(GPIO_PIOC_BASE + 16)
+#define GPIO_PIN_PC17	(GPIO_PIOC_BASE + 17)
+#define GPIO_PIN_PC18	(GPIO_PIOC_BASE + 18)
+#define GPIO_PIN_PC19	(GPIO_PIOC_BASE + 19)
+#define GPIO_PIN_PC20	(GPIO_PIOC_BASE + 20)
+#define GPIO_PIN_PC21	(GPIO_PIOC_BASE + 21)
+#define GPIO_PIN_PC22	(GPIO_PIOC_BASE + 22)
+#define GPIO_PIN_PC23	(GPIO_PIOC_BASE + 23)
+#define GPIO_PIN_PC24	(GPIO_PIOC_BASE + 24)
+#define GPIO_PIN_PC25	(GPIO_PIOC_BASE + 25)
+#define GPIO_PIN_PC26	(GPIO_PIOC_BASE + 26)
+#define GPIO_PIN_PC27	(GPIO_PIOC_BASE + 27)
+#define GPIO_PIN_PC28	(GPIO_PIOC_BASE + 28)
+#define GPIO_PIN_PC29	(GPIO_PIOC_BASE + 29)
+#define GPIO_PIN_PC30	(GPIO_PIOC_BASE + 30)
+#define GPIO_PIN_PC31	(GPIO_PIOC_BASE + 31)
+
+#define GPIO_PIOD_BASE	(GPIO_PIOC_BASE + 32)
+#define GPIO_PIN_PD0	(GPIO_PIOD_BASE +  0)
+#define GPIO_PIN_PD1	(GPIO_PIOD_BASE +  1)
+#define GPIO_PIN_PD2	(GPIO_PIOD_BASE +  2)
+#define GPIO_PIN_PD3	(GPIO_PIOD_BASE +  3)
+#define GPIO_PIN_PD4	(GPIO_PIOD_BASE +  4)
+#define GPIO_PIN_PD5	(GPIO_PIOD_BASE +  5)
+#define GPIO_PIN_PD6	(GPIO_PIOD_BASE +  6)
+#define GPIO_PIN_PD7	(GPIO_PIOD_BASE +  7)
+#define GPIO_PIN_PD8	(GPIO_PIOD_BASE +  8)
+#define GPIO_PIN_PD9	(GPIO_PIOD_BASE +  9)
+#define GPIO_PIN_PD10	(GPIO_PIOD_BASE + 10)
+#define GPIO_PIN_PD11	(GPIO_PIOD_BASE + 11)
+#define GPIO_PIN_PD12	(GPIO_PIOD_BASE + 12)
+#define GPIO_PIN_PD13	(GPIO_PIOD_BASE + 13)
+#define GPIO_PIN_PD14	(GPIO_PIOD_BASE + 14)
+#define GPIO_PIN_PD15	(GPIO_PIOD_BASE + 15)
+#define GPIO_PIN_PD16	(GPIO_PIOD_BASE + 16)
+#define GPIO_PIN_PD17	(GPIO_PIOD_BASE + 17)
+
+#define GPIO_PIOE_BASE	(GPIO_PIOD_BASE + 32)
+#define GPIO_PIN_PE0	(GPIO_PIOE_BASE +  0)
+#define GPIO_PIN_PE1	(GPIO_PIOE_BASE +  1)
+#define GPIO_PIN_PE2	(GPIO_PIOE_BASE +  2)
+#define GPIO_PIN_PE3	(GPIO_PIOE_BASE +  3)
+#define GPIO_PIN_PE4	(GPIO_PIOE_BASE +  4)
+#define GPIO_PIN_PE5	(GPIO_PIOE_BASE +  5)
+#define GPIO_PIN_PE6	(GPIO_PIOE_BASE +  6)
+#define GPIO_PIN_PE7	(GPIO_PIOE_BASE +  7)
+#define GPIO_PIN_PE8	(GPIO_PIOE_BASE +  8)
+#define GPIO_PIN_PE9	(GPIO_PIOE_BASE +  9)
+#define GPIO_PIN_PE10	(GPIO_PIOE_BASE + 10)
+#define GPIO_PIN_PE11	(GPIO_PIOE_BASE + 11)
+#define GPIO_PIN_PE12	(GPIO_PIOE_BASE + 12)
+#define GPIO_PIN_PE13	(GPIO_PIOE_BASE + 13)
+#define GPIO_PIN_PE14	(GPIO_PIOE_BASE + 14)
+#define GPIO_PIN_PE15	(GPIO_PIOE_BASE + 15)
+#define GPIO_PIN_PE16	(GPIO_PIOE_BASE + 16)
+#define GPIO_PIN_PE17	(GPIO_PIOE_BASE + 17)
+#define GPIO_PIN_PE18	(GPIO_PIOE_BASE + 18)
+#define GPIO_PIN_PE19	(GPIO_PIOE_BASE + 19)
+#define GPIO_PIN_PE20	(GPIO_PIOE_BASE + 20)
+#define GPIO_PIN_PE21	(GPIO_PIOE_BASE + 21)
+#define GPIO_PIN_PE22	(GPIO_PIOE_BASE + 22)
+#define GPIO_PIN_PE23	(GPIO_PIOE_BASE + 23)
+#define GPIO_PIN_PE24	(GPIO_PIOE_BASE + 24)
+#define GPIO_PIN_PE25	(GPIO_PIOE_BASE + 25)
+#define GPIO_PIN_PE26	(GPIO_PIOE_BASE + 26)
+
+static inline void *gpio_pin_to_addr(unsigned int pin)
+{
+	switch (pin >> 5) {
+	case 0:
+		return (void *)PIOA_BASE;
+	case 1:
+		return (void *)PIOB_BASE;
+	case 2:
+		return (void *)PIOC_BASE;
+	case 3:
+		return (void *)PIOD_BASE;
+	case 4:
+		return (void *)PIOE_BASE;
+	default:
+		return NULL;
+	}
+}
+
+void gpio_select_periph_A(unsigned int pin, int use_pullup);
+void gpio_select_periph_B(unsigned int pin, int use_pullup);
+
+void gpio_enable_ebi(void);
+
+#ifdef AT32AP700x_CHIP_HAS_USART
+void gpio_enable_usart0(void);
+void gpio_enable_usart1(void);
+void gpio_enable_usart2(void);
+void gpio_enable_usart3(void);
+#endif
+#ifdef AT32AP700x_CHIP_HAS_MACB
+void gpio_enable_macb0(void);
+void gpio_enable_macb1(void);
+#endif
+#ifdef AT32AP700x_CHIP_HAS_MMCI
+void gpio_enable_mmci(void);
+#endif
+
+#endif /* __ASM_AVR32_ARCH_GPIO_H__ */
diff --git a/include/asm-avr32/arch-at32ap700x/hmatrix2.h b/include/asm-avr32/arch-at32ap700x/hmatrix2.h
new file mode 100644
index 0000000..b0e787a
--- /dev/null
+++ b/include/asm-avr32/arch-at32ap700x/hmatrix2.h
@@ -0,0 +1,232 @@
+/*
+ * Register definition for the High-speed Bus Matrix
+ */
+#ifndef __ASM_AVR32_HMATRIX2_H__
+#define __ASM_AVR32_HMATRIX2_H__
+
+/* HMATRIX2 register offsets */
+#define HMATRIX2_MCFG0				0x0000
+#define HMATRIX2_MCFG1				0x0004
+#define HMATRIX2_MCFG2				0x0008
+#define HMATRIX2_MCFG3				0x000c
+#define HMATRIX2_MCFG4				0x0010
+#define HMATRIX2_MCFG5				0x0014
+#define HMATRIX2_MCFG6				0x0018
+#define HMATRIX2_MCFG7				0x001c
+#define HMATRIX2_MCFG8				0x0020
+#define HMATRIX2_MCFG9				0x0024
+#define HMATRIX2_MCFG10				0x0028
+#define HMATRIX2_MCFG11				0x002c
+#define HMATRIX2_MCFG12				0x0030
+#define HMATRIX2_MCFG13				0x0034
+#define HMATRIX2_MCFG14				0x0038
+#define HMATRIX2_MCFG15				0x003c
+#define HMATRIX2_SCFG0				0x0040
+#define HMATRIX2_SCFG1				0x0044
+#define HMATRIX2_SCFG2				0x0048
+#define HMATRIX2_SCFG3				0x004c
+#define HMATRIX2_SCFG4				0x0050
+#define HMATRIX2_SCFG5				0x0054
+#define HMATRIX2_SCFG6				0x0058
+#define HMATRIX2_SCFG7				0x005c
+#define HMATRIX2_SCFG8				0x0060
+#define HMATRIX2_SCFG9				0x0064
+#define HMATRIX2_SCFG10				0x0068
+#define HMATRIX2_SCFG11				0x006c
+#define HMATRIX2_SCFG12				0x0070
+#define HMATRIX2_SCFG13				0x0074
+#define HMATRIX2_SCFG14				0x0078
+#define HMATRIX2_SCFG15				0x007c
+#define HMATRIX2_PRAS0				0x0080
+#define HMATRIX2_PRBS0				0x0084
+#define HMATRIX2_PRAS1				0x0088
+#define HMATRIX2_PRBS1				0x008c
+#define HMATRIX2_PRAS2				0x0090
+#define HMATRIX2_PRBS2				0x0094
+#define HMATRIX2_PRAS3				0x0098
+#define HMATRIX2_PRBS3				0x009c
+#define HMATRIX2_PRAS4				0x00a0
+#define HMATRIX2_PRBS4				0x00a4
+#define HMATRIX2_PRAS5				0x00a8
+#define HMATRIX2_PRBS5				0x00ac
+#define HMATRIX2_PRAS6				0x00b0
+#define HMATRIX2_PRBS6				0x00b4
+#define HMATRIX2_PRAS7				0x00b8
+#define HMATRIX2_PRBS7				0x00bc
+#define HMATRIX2_PRAS8				0x00c0
+#define HMATRIX2_PRBS8				0x00c4
+#define HMATRIX2_PRAS9				0x00c8
+#define HMATRIX2_PRBS9				0x00cc
+#define HMATRIX2_PRAS10				0x00d0
+#define HMATRIX2_PRBS10				0x00d4
+#define HMATRIX2_PRAS11				0x00d8
+#define HMATRIX2_PRBS11				0x00dc
+#define HMATRIX2_PRAS12				0x00e0
+#define HMATRIX2_PRBS12				0x00e4
+#define HMATRIX2_PRAS13				0x00e8
+#define HMATRIX2_PRBS13				0x00ec
+#define HMATRIX2_PRAS14				0x00f0
+#define HMATRIX2_PRBS14				0x00f4
+#define HMATRIX2_PRAS15				0x00f8
+#define HMATRIX2_PRBS15				0x00fc
+#define HMATRIX2_MRCR				0x0100
+#define HMATRIX2_SFR0				0x0110
+#define HMATRIX2_SFR1				0x0114
+#define HMATRIX2_SFR2				0x0118
+#define HMATRIX2_SFR3				0x011c
+#define HMATRIX2_SFR4				0x0120
+#define HMATRIX2_SFR5				0x0124
+#define HMATRIX2_SFR6				0x0128
+#define HMATRIX2_SFR7				0x012c
+#define HMATRIX2_SFR8				0x0130
+#define HMATRIX2_SFR9				0x0134
+#define HMATRIX2_SFR10				0x0138
+#define HMATRIX2_SFR11				0x013c
+#define HMATRIX2_SFR12				0x0140
+#define HMATRIX2_SFR13				0x0144
+#define HMATRIX2_SFR14				0x0148
+#define HMATRIX2_SFR15				0x014c
+#define HMATRIX2_VERSION			0x01fc
+
+/* Bitfields in MCFG0 */
+#define HMATRIX2_ULBT_OFFSET			0
+#define HMATRIX2_ULBT_SIZE			3
+
+/* Bitfields in SCFG0 */
+#define HMATRIX2_SLOT_CYCLE_OFFSET		0
+#define HMATRIX2_SLOT_CYCLE_SIZE		8
+#define HMATRIX2_DEFMSTR_TYPE_OFFSET		16
+#define HMATRIX2_DEFMSTR_TYPE_SIZE		2
+#define HMATRIX2_FIXED_DEFMSTR_OFFSET		18
+#define HMATRIX2_FIXED_DEFMSTR_SIZE		4
+#define HMATRIX2_ARBT_OFFSET			24
+#define HMATRIX2_ARBT_SIZE			2
+
+/* Bitfields in PRAS0 */
+#define HMATRIX2_M0PR_OFFSET			0
+#define HMATRIX2_M0PR_SIZE			4
+#define HMATRIX2_M1PR_OFFSET			4
+#define HMATRIX2_M1PR_SIZE			4
+#define HMATRIX2_M2PR_OFFSET			8
+#define HMATRIX2_M2PR_SIZE			4
+#define HMATRIX2_M3PR_OFFSET			12
+#define HMATRIX2_M3PR_SIZE			4
+#define HMATRIX2_M4PR_OFFSET			16
+#define HMATRIX2_M4PR_SIZE			4
+#define HMATRIX2_M5PR_OFFSET			20
+#define HMATRIX2_M5PR_SIZE			4
+#define HMATRIX2_M6PR_OFFSET			24
+#define HMATRIX2_M6PR_SIZE			4
+#define HMATRIX2_M7PR_OFFSET			28
+#define HMATRIX2_M7PR_SIZE			4
+
+/* Bitfields in PRBS0 */
+#define HMATRIX2_M8PR_OFFSET			0
+#define HMATRIX2_M8PR_SIZE			4
+#define HMATRIX2_M9PR_OFFSET			4
+#define HMATRIX2_M9PR_SIZE			4
+#define HMATRIX2_M10PR_OFFSET			8
+#define HMATRIX2_M10PR_SIZE			4
+#define HMATRIX2_M11PR_OFFSET			12
+#define HMATRIX2_M11PR_SIZE			4
+#define HMATRIX2_M12PR_OFFSET			16
+#define HMATRIX2_M12PR_SIZE			4
+#define HMATRIX2_M13PR_OFFSET			20
+#define HMATRIX2_M13PR_SIZE			4
+#define HMATRIX2_M14PR_OFFSET			24
+#define HMATRIX2_M14PR_SIZE			4
+#define HMATRIX2_M15PR_OFFSET			28
+#define HMATRIX2_M15PR_SIZE			4
+
+/* Bitfields in MRCR */
+#define HMATRIX2_RBC0_OFFSET			0
+#define HMATRIX2_RBC0_SIZE			1
+#define HMATRIX2_RBC1_OFFSET			1
+#define HMATRIX2_RBC1_SIZE			1
+#define HMATRIX2_RBC2_OFFSET			2
+#define HMATRIX2_RBC2_SIZE			1
+#define HMATRIX2_RBC3_OFFSET			3
+#define HMATRIX2_RBC3_SIZE			1
+#define HMATRIX2_RBC4_OFFSET			4
+#define HMATRIX2_RBC4_SIZE			1
+#define HMATRIX2_RBC5_OFFSET			5
+#define HMATRIX2_RBC5_SIZE			1
+#define HMATRIX2_RBC6_OFFSET			6
+#define HMATRIX2_RBC6_SIZE			1
+#define HMATRIX2_RBC7_OFFSET			7
+#define HMATRIX2_RBC7_SIZE			1
+#define HMATRIX2_RBC8_OFFSET			8
+#define HMATRIX2_RBC8_SIZE			1
+#define HMATRIX2_RBC9_OFFSET			9
+#define HMATRIX2_RBC9_SIZE			1
+#define HMATRIX2_RBC10_OFFSET			10
+#define HMATRIX2_RBC10_SIZE			1
+#define HMATRIX2_RBC11_OFFSET			11
+#define HMATRIX2_RBC11_SIZE			1
+#define HMATRIX2_RBC12_OFFSET			12
+#define HMATRIX2_RBC12_SIZE			1
+#define HMATRIX2_RBC13_OFFSET			13
+#define HMATRIX2_RBC13_SIZE			1
+#define HMATRIX2_RBC14_OFFSET			14
+#define HMATRIX2_RBC14_SIZE			1
+#define HMATRIX2_RBC15_OFFSET			15
+#define HMATRIX2_RBC15_SIZE			1
+
+/* Bitfields in SFR0 */
+#define HMATRIX2_SFR_OFFSET			0
+#define HMATRIX2_SFR_SIZE			32
+
+/* Bitfields in SFR4 */
+#define HMATRIX2_CS1A_OFFSET			1
+#define HMATRIX2_CS1A_SIZE			1
+#define HMATRIX2_CS3A_OFFSET			3
+#define HMATRIX2_CS3A_SIZE			1
+#define HMATRIX2_CS4A_OFFSET			4
+#define HMATRIX2_CS4A_SIZE			1
+#define HMATRIX2_CS5A_OFFSET			5
+#define HMATRIX2_CS5A_SIZE			1
+#define HMATRIX2_DBPUC_OFFSET			8
+#define HMATRIX2_DBPUC_SIZE			1
+
+/* Bitfields in VERSION */
+#define HMATRIX2_VERSION_OFFSET			0
+#define HMATRIX2_VERSION_SIZE			12
+#define HMATRIX2_MFN_OFFSET			16
+#define HMATRIX2_MFN_SIZE			3
+
+/* Constants for ULBT */
+#define HMATRIX2_ULBT_INFINITE			0
+#define HMATRIX2_ULBT_SINGLE			1
+#define HMATRIX2_ULBT_FOUR_BEAT			2
+#define HMATRIX2_ULBT_SIXTEEN_BEAT		4
+
+/* Constants for DEFMSTR_TYPE */
+#define HMATRIX2_DEFMSTR_TYPE_NO_DEFAULT	0
+#define HMATRIX2_DEFMSTR_TYPE_LAST_DEFAULT	1
+#define HMATRIX2_DEFMSTR_TYPE_FIXED_DEFAULT	2
+
+/* Constants for ARBT */
+#define HMATRIX2_ARBT_ROUND_ROBIN		0
+#define HMATRIX2_ARBT_FIXED_PRIORITY		1
+
+/* Bit manipulation macros */
+#define HMATRIX2_BIT(name)					\
+	(1 << HMATRIX2_##name##_OFFSET)
+#define HMATRIX2_BF(name,value)					\
+	(((value) & ((1 << HMATRIX2_##name##_SIZE) - 1))	\
+	 << HMATRIX2_##name##_OFFSET)
+#define HMATRIX2_BFEXT(name,value)				\
+	(((value) >> HMATRIX2_##name##_OFFSET)			\
+	 & ((1 << HMATRIX2_##name##_SIZE) - 1))
+#define HMATRIX2_BFINS(name,value,old)				\
+	(((old) & ~(((1 << HMATRIX2_##name##_SIZE) - 1)		\
+		    << HMATRIX2_##name##_OFFSET))		\
+	 | HMATRIX2_BF(name,value))
+
+/* Register access macros */
+#define hmatrix2_readl(reg)					\
+	readl((void *)HMATRIX_BASE + HMATRIX2_##reg)
+#define hmatrix2_writel(reg,value)				\
+	writel((value), (void *)HMATRIX_BASE + HMATRIX2_##reg)
+
+#endif /* __ASM_AVR32_HMATRIX2_H__ */
diff --git a/include/asm-avr32/arch-at32ap700x/memory-map.h b/include/asm-avr32/arch-at32ap700x/memory-map.h
new file mode 100644
index 0000000..5513e88
--- /dev/null
+++ b/include/asm-avr32/arch-at32ap700x/memory-map.h
@@ -0,0 +1,66 @@
+/*
+ * Copyright (C) 2005-2006 Atmel Corporation
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#ifndef __AT32AP7000_MEMORY_MAP_H__
+#define __AT32AP7000_MEMORY_MAP_H__
+
+/* Devices on the High Speed Bus (HSB) */
+#define LCDC_BASE				0xFF000000
+#define DMAC_BASE				0xFF200000
+#define USB_FIFO				0xFF300000
+
+/* Devices on Peripheral Bus A (PBA) */
+#define SPI0_BASE				0xFFE00000
+#define SPI1_BASE				0xFFE00400
+#define TWI_BASE				0xFFE00800
+#define USART0_BASE				0xFFE00C00
+#define USART1_BASE				0xFFE01000
+#define USART2_BASE				0xFFE01400
+#define USART3_BASE				0xFFE01800
+#define SSC0_BASE				0xFFE01C00
+#define SSC1_BASE				0xFFE02000
+#define SSC2_BASE				0xFFE02400
+#define PIOA_BASE				0xFFE02800
+#define PIOB_BASE				0xFFE02C00
+#define PIOC_BASE				0xFFE03000
+#define PIOD_BASE				0xFFE03400
+#define PIOE_BASE				0xFFE03800
+#define PSIF_BASE				0xFFE03C00
+
+/* Devices on Peripheral Bus B (PBB) */
+#define SM_BASE					0xFFF00000
+#define INTC_BASE				0xFFF00400
+#define HMATRIX_BASE				0xFFF00800
+#define TIMER0_BASE				0xFFF00C00
+#define TIMER1_BASE				0xFFF01000
+#define PWM_BASE				0xFFF01400
+#define MACB0_BASE				0xFFF01800
+#define MACB1_BASE				0xFFF01C00
+#define DAC_BASE				0xFFF02000
+#define MMCI_BASE				0xFFF02400
+#define AUDIOC_BASE				0xFFF02800
+#define HISI_BASE				0xFFF02C00
+#define USB_BASE				0xFFF03000
+#define HSMC_BASE				0xFFF03400
+#define HSDRAMC_BASE				0xFFF03800
+#define ECC_BASE				0xFFF03C00
+
+#endif /* __AT32AP7000_MEMORY_MAP_H__ */
diff --git a/include/asm-avr32/arch-at32ap700x/mmc.h b/include/asm-avr32/arch-at32ap700x/mmc.h
new file mode 100644
index 0000000..fcfbbb3
--- /dev/null
+++ b/include/asm-avr32/arch-at32ap700x/mmc.h
@@ -0,0 +1,96 @@
+/*
+ * Copyright (C) 2004-2006 Atmel Corporation
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#ifndef __ASM_AVR32_MMC_H
+#define __ASM_AVR32_MMC_H
+
+struct mmc_cid {
+	unsigned long psn;
+	unsigned short oid;
+	unsigned char mid;
+	unsigned char prv;
+	unsigned char mdt;
+	char pnm[7];
+};
+
+struct mmc_csd
+{
+	u8	csd_structure:2,
+		spec_vers:4,
+		rsvd1:2;
+	u8	taac;
+	u8	nsac;
+	u8	tran_speed;
+	u16	ccc:12,
+		read_bl_len:4;
+	u64	read_bl_partial:1,
+		write_blk_misalign:1,
+		read_blk_misalign:1,
+		dsr_imp:1,
+		rsvd2:2,
+		c_size:12,
+		vdd_r_curr_min:3,
+		vdd_r_curr_max:3,
+		vdd_w_curr_min:3,
+		vdd_w_curr_max:3,
+		c_size_mult:3,
+		sector_size:5,
+		erase_grp_size:5,
+		wp_grp_size:5,
+		wp_grp_enable:1,
+		default_ecc:2,
+		r2w_factor:3,
+		write_bl_len:4,
+		write_bl_partial:1,
+		rsvd3:5;
+	u8	file_format_grp:1,
+		copy:1,
+		perm_write_protect:1,
+		tmp_write_protect:1,
+		file_format:2,
+		ecc:2;
+	u8	crc:7;
+	u8	one:1;
+};
+
+/* MMC Command numbers */
+#define MMC_CMD_GO_IDLE_STATE		0
+#define MMC_CMD_SEND_OP_COND		1
+#define MMC_CMD_ALL_SEND_CID 		2
+#define MMC_CMD_SET_RELATIVE_ADDR	3
+#define MMC_CMD_SD_SEND_RELATIVE_ADDR	3
+#define MMC_CMD_SET_DSR			4
+#define MMC_CMD_SELECT_CARD		7
+#define MMC_CMD_SEND_CSD 		9
+#define MMC_CMD_SEND_CID 		10
+#define MMC_CMD_SEND_STATUS		13
+#define MMC_CMD_SET_BLOCKLEN		16
+#define MMC_CMD_READ_SINGLE_BLOCK	17
+#define MMC_CMD_READ_MULTIPLE_BLOCK	18
+#define MMC_CMD_WRITE_BLOCK		24
+#define MMC_CMD_APP_CMD			55
+
+#define MMC_ACMD_SD_SEND_OP_COND	41
+
+#define R1_ILLEGAL_COMMAND		(1 << 22)
+#define R1_APP_CMD			(1 << 5)
+
+#endif /* __ASM_AVR32_MMC_H */
diff --git a/include/asm-mips/string.h b/include/asm-mips/string.h
index c42ad82..579a591 100644
--- a/include/asm-mips/string.h
+++ b/include/asm-mips/string.h
@@ -19,21 +19,21 @@
 extern char *strcpy(char *__dest, __const__ char *__src);
 
 #undef __HAVE_ARCH_STRNCPY
-extern char *strncpy(char *__dest, __const__ char *__src, size_t __n);
+extern char *strncpy(char *__dest, __const__ char *__src, __kernel_size_t __n);
 
 #undef __HAVE_ARCH_STRCMP
 extern int strcmp(__const__ char *__cs, __const__ char *__ct);
 
 #undef __HAVE_ARCH_STRNCMP
-extern int strncmp(__const__ char *__cs, __const__ char *__ct, size_t __count);
+extern int strncmp(__const__ char *__cs, __const__ char *__ct, __kernel_size_t __count);
 
 #undef __HAVE_ARCH_MEMSET
-extern void *memset(void *__s, int __c, size_t __count);
+extern void *memset(void *__s, int __c, __kernel_size_t __count);
 
 #undef __HAVE_ARCH_MEMCPY
-extern void *memcpy(void *__to, __const__ void *__from, size_t __n);
+extern void *memcpy(void *__to, __const__ void *__from, __kernel_size_t __n);
 
 #undef __HAVE_ARCH_MEMMOVE
-extern void *memmove(void *__dest, __const__ void *__src, size_t __n);
+extern void *memmove(void *__dest, __const__ void *__src, __kernel_size_t __n);
 
 #endif /* _ASM_STRING_H */
diff --git a/include/configs/MPC8266ADS.h b/include/configs/MPC8266ADS.h
index 14b041e..3659002 100644
--- a/include/configs/MPC8266ADS.h
+++ b/include/configs/MPC8266ADS.h
@@ -146,37 +146,26 @@
 /*
  * Command line configuration.
  */
-#include <config_cmd_all.h>
-
-#undef CONFIG_CMD_BEDBUG
-#undef CONFIG_CMD_BMP
-#undef CONFIG_CMD_BSP
-#undef CONFIG_CMD_DATE
-#undef CONFIG_CMD_DHCP
-#undef CONFIG_CMD_DISPLAY
-#undef CONFIG_CMD_DOC
-#undef CONFIG_CMD_DTT
-#undef CONFIG_CMD_EEPROM
-#undef CONFIG_CMD_ELF
-#undef CONFIG_CMD_EXT2
-#undef CONFIG_CMD_FDC
-#undef CONFIG_CMD_FDOS
-#undef CONFIG_CMD_HWFLOW
-#undef CONFIG_CMD_IDE
-#undef CONFIG_CMD_JFFS2
-#undef CONFIG_CMD_KGDB
-#undef CONFIG_CMD_MFSL
-#undef CONFIG_CMD_MMC
-#undef CONFIG_CMD_NAND
-#undef CONFIG_CMD_PCMCIA
-#undef CONFIG_CMD_REISER
-#undef CONFIG_CMD_SCSI
-#undef CONFIG_CMD_SPI
-#undef CONFIG_CMD_SNTP
-#undef CONFIG_CMD_VFD
-#undef CONFIG_CMD_UNIVERSE
-#undef CONFIG_CMD_USB
-#undef CONFIG_CMD_XIMG
+#include <config_cmd_default.h>
+
+/* Commands we want, that are not part of default set */
+#define CONFIG_CMD_ASKENV	/* ask for env variable		*/
+#define CONFIG_CMD_CACHE	/* icache, dcache		*/
+#define CONFIG_CMD_DHCP		/* DHCP Support			*/
+#define CONFIG_CMD_DIAG		/* Diagnostics			*/
+#define CONFIG_CMD_IMMAP	/* IMMR dump support		*/
+#define CONFIG_CMD_IRQ		/* irqinfo			*/
+#define CONFIG_CMD_MII		/* MII support			*/
+#define CONFIG_CMD_PCI		/* pciinfo			*/
+#define CONFIG_CMD_PING		/* ping support			*/
+#define CONFIG_CMD_PORTIO	/* Port I/O			*/
+#define CONFIG_CMD_REGINFO	/* Register dump		*/
+#define CONFIG_CMD_SAVES	/* save S record dump		*/
+#define CONFIG_CMD_SDRAM	/* SDRAM DIMM SPD info printout */
+
+/* Commands from default set we don't need */
+#undef CONFIG_CMD_FPGA		/* FPGA configuration Support	*/
+#undef CONFIG_CMD_SETGETDCR	/* DCR support on 4xx		*/
 
 /* Define a command string that is automatically executed when no character
  * is read on the console interface withing "Boot Delay" after reset.
diff --git a/include/configs/TQM5200.h b/include/configs/TQM5200.h
index d553404..7ecc275 100644
--- a/include/configs/TQM5200.h
+++ b/include/configs/TQM5200.h
@@ -257,8 +257,8 @@
 	"fdt_addr=FC0A0000\0"						\
 	"kernel_addr=FC0C0000\0"					\
 	"ramdisk_addr=FC300000\0"					\
-	"kernel_addr_r=200000\0"					\
-	"fdt_addr_r=400000\0"						\
+	"kernel_addr_r=400000\0"					\
+	"fdt_addr_r=600000\0"						\
 	"rootpath=/opt/eldk/ppc_6xx\0"					\
 	"ramargs=setenv bootargs root=/dev/ram rw\0"			\
 	"nfsargs=setenv bootargs root=/dev/nfs rw "			\
@@ -547,7 +547,7 @@
 #  if defined (CONFIG_TQM5200_REV100)
 #   error TQM5200 REV100 not supported on STK52XX REV200 or above
 #  else/* TQM5200 REV200 and above */
-#   define CFG_GPS_PORT_CONFIG	0x91500004
+#   define CFG_GPS_PORT_CONFIG	0x91500404
 #  endif
 # endif
 #elif defined (CONFIG_FO300)
diff --git a/include/configs/TQM860M.h b/include/configs/TQM860M.h
index 684b86f..fe3a2f0 100644
--- a/include/configs/TQM860M.h
+++ b/include/configs/TQM860M.h
@@ -69,9 +69,14 @@
 	"net_nfs=tftp 200000 ${bootfile};run nfsargs addip;bootm\0"	\
 	"rootpath=/opt/eldk/ppc_8xx\0"					\
 	"bootfile=/tftpboot/TQM860M/uImage\0"				\
-	"fdt_addr=40080000\0"						\
-	"kernel_addr=400A0000\0"					\
+	"fdt_addr=400C0000\0"						\
+	"kernel_addr=40100000\0"					\
 	"ramdisk_addr=40280000\0"					\
+	"load=tftp 200000 ${u-boot}\0"					\
+	"update=protect off 40000000 +${filesize};"			\
+		"erase 40000000 +${filesize};"				\
+		"cp.b 200000 40000000 ${filesize};"			\
+		"protect on 40000000 +${filesize}\0"			\
 	""
 #define CONFIG_BOOTCOMMAND	"run flash_self"
 
@@ -172,7 +177,7 @@
 #define CFG_FLASH_BASE		0x40000000
 #define	CFG_MONITOR_LEN		(256 << 10)	/* Reserve 256 kB for Monitor	*/
 #define CFG_MONITOR_BASE	CFG_FLASH_BASE
-#define	CFG_MALLOC_LEN		(128 << 10)	/* Reserve 128 kB for malloc()	*/
+#define	CFG_MALLOC_LEN		(256 << 10)	/* Reserve 256 kB for malloc()	*/
 
 /*
  * For booting Linux, the board info and command line data
@@ -193,7 +198,7 @@
 #define	CFG_ENV_IS_IN_FLASH	1
 #define	CFG_ENV_OFFSET		0x40000	/*   Offset   of Environment Sector	*/
 #define	CFG_ENV_SIZE		0x08000	/* Total Size of Environment Sector	*/
-#define	CFG_ENV_SECT_SIZE	0x20000	/* Total Size of Environment Sector	*/
+#define	CFG_ENV_SECT_SIZE	0x40000	/* Total Size of Environment Sector	*/
 
 /* Address and size of Redundant Environment Sector	*/
 #define CFG_ENV_OFFSET_REDUND	(CFG_ENV_OFFSET+CFG_ENV_SECT_SIZE)
diff --git a/include/configs/TQM866M.h b/include/configs/TQM866M.h
index 0d77891..ca3c166 100644
--- a/include/configs/TQM866M.h
+++ b/include/configs/TQM866M.h
@@ -81,9 +81,14 @@
 	"net_nfs=tftp 200000 ${bootfile};run nfsargs addip;bootm\0"	\
 	"rootpath=/opt/eldk/ppc_8xx\0"					\
 	"bootfile=/tftpboot/TQM866M/uImage\0"				\
-	"fdt_addr=40080000\0"						\
-	"kernel_addr=400A0000\0"					\
+	"fdt_addr=400C0000\0"						\
+	"kernel_addr=40100000\0"					\
 	"ramdisk_addr=40280000\0"					\
+	"load=tftp 200000 ${u-boot}\0"					\
+	"update=protect off 40000000 +${filesize};"			\
+		"erase 40000000 +${filesize};"				\
+		"cp.b 200000 40000000 ${filesize};"			\
+		"protect on 40000000 +${filesize}\0"			\
 	""
 #define CONFIG_BOOTCOMMAND	"run flash_self"
 
@@ -215,7 +220,7 @@
 #define CFG_FLASH_BASE		0x40000000
 #define CFG_MONITOR_LEN		(256 << 10)	/* Reserve 256 kB for Monitor	*/
 #define CFG_MONITOR_BASE	CFG_FLASH_BASE
-#define CFG_MALLOC_LEN		(128 << 10)	/* Reserve 128 kB for malloc()	*/
+#define CFG_MALLOC_LEN		(256 << 10)	/* Reserve 256 kB for malloc()	*/
 
 /*
  * For booting Linux, the board info and command line data
@@ -236,7 +241,7 @@
 #define CFG_ENV_IS_IN_FLASH	1
 #define CFG_ENV_OFFSET		0x40000 /*   Offset   of Environment Sector	*/
 #define CFG_ENV_SIZE		0x08000 /* Total Size of Environment Sector	*/
-#define CFG_ENV_SECT_SIZE	0x20000 /* Total Size of Environment Sector	*/
+#define CFG_ENV_SECT_SIZE	0x40000 /* Total Size of Environment Sector	*/
 
 /* Address and size of Redundant Environment Sector	*/
 #define CFG_ENV_OFFSET_REDUND	(CFG_ENV_OFFSET+CFG_ENV_SECT_SIZE)
@@ -421,26 +426,30 @@
 #define CFG_PTA_PER_CLK	((4096 * 64 * 1000) / (4 * 64))
 
 /*
- * Memory Periodic Timer Prescaler
- * Periodic timer for refresh, start with refresh rate for 40 MHz clock
- * (CFG_8xx_CPUCLK_MIN / CFG_PTA_PER_CLK)
+ * Periodic timer (MAMR[PTx]) for 4 * 7.8 us refresh (= 31.2 us per quad)
+ *
+ *                        CPUclock(MHz) * 31.2
+ * CFG_MAMR_PTA = -----------------------------------     with DFBRG = 0
+ *                2^(2*SCCR[DFBRG]) * MPTPR_PTP_DIV16
+ *
+ * CPU clock =  15 MHz:  CFG_MAMR_PTA =  29   ->  4 * 7.73 us
+ * CPU clock =  50 MHz:  CFG_MAMR_PTA =  97   ->  4 * 7.76 us
+ * CPU clock =  66 MHz:  CFG_MAMR_PTA = 128   ->  4 * 7.75 us
+ * CPU clock = 133 MHz:  CFG_MAMR_PTA = 255   ->  4 * 7.67 us
+ *
+ * Value 97 is for 4 * 7.8 us at 50 MHz. So the refresh cycle requirement will
+ * be met also in the default configuration, i.e. if environment variable
+ * 'cpuclk' is not set.
  */
-#define CFG_MAMR_PTA		39
+#define CFG_MAMR_PTA		97
 
 /*
- * For 16 MBit, refresh rates could be 31.3 us
- * (= 64 ms / 2K = 125 / quad bursts).
- * For a simpler initialization, 15.6 us is used instead.
- *
- * #define CFG_MPTPR_2BK_2K	MPTPR_PTP_DIV32		for 2 banks
- * #define CFG_MPTPR_1BK_2K	MPTPR_PTP_DIV64		for 1 bank
+ * Memory Periodic Timer Prescaler Register (MPTPR) values.
  */
-#define CFG_MPTPR_2BK_4K	MPTPR_PTP_DIV16		/* setting for 2 banks	*/
-#define CFG_MPTPR_1BK_4K	MPTPR_PTP_DIV32		/* setting for 1 bank	*/
-
-/* refresh rate 7.8 us (= 64 ms / 8K = 31.2 / quad bursts) for 256 MBit		*/
-#define CFG_MPTPR_2BK_8K	MPTPR_PTP_DIV8		/* setting for 2 banks	*/
-#define CFG_MPTPR_1BK_8K	MPTPR_PTP_DIV16		/* setting for 1 bank	*/
+/* 4 * 7.8 us refresh (= 31.2 us per quad) at 50 MHz and PTA = 97 */
+#define CFG_MPTPR_2BK_4K	MPTPR_PTP_DIV16
+/* 4 * 3.9 us refresh (= 15.6 us per quad) at 50 MHz and PTA = 97 */
+#define CFG_MPTPR_2BK_8K	MPTPR_PTP_DIV8
 
 /*
  * MAMR settings for SDRAM
diff --git a/include/configs/atngw100.h b/include/configs/atngw100.h
new file mode 100644
index 0000000..d70b71c
--- /dev/null
+++ b/include/configs/atngw100.h
@@ -0,0 +1,181 @@
+/*
+ * Copyright (C) 2006 Atmel Corporation
+ *
+ * Configuration settings for the AVR32 Network Gateway
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#define CONFIG_AVR32			1
+#define CONFIG_AT32AP			1
+#define CONFIG_AT32AP7000		1
+#define CONFIG_ATNGW100			1
+
+#define CONFIG_ATNGW100_EXT_FLASH	1
+
+#define CFG_HZ				1000
+
+/*
+ * Set up the PLL to run at 140 MHz, the CPU to run at the PLL
+ * frequency, the HSB and PBB busses to run at 1/2 the PLL frequency
+ * and the PBA bus to run at 1/4 the PLL frequency.
+ */
+#define CONFIG_PLL			1
+#define CFG_POWER_MANAGER		1
+#define CFG_OSC0_HZ			20000000
+#define CFG_PLL0_DIV			1
+#define CFG_PLL0_MUL			7
+#define CFG_PLL0_SUPPRESS_CYCLES	16
+#define CFG_CLKDIV_CPU			0
+#define CFG_CLKDIV_HSB			1
+#define CFG_CLKDIV_PBA			2
+#define CFG_CLKDIV_PBB			1
+
+/*
+ * The PLLOPT register controls the PLL like this:
+ *   icp = PLLOPT<2>
+ *   ivco = PLLOPT<1:0>
+ *
+ * We want icp=1 (default) and ivco=0 (80-160 MHz) or ivco=2 (150-240MHz).
+ */
+#define CFG_PLL0_OPT			0x04
+
+#define CONFIG_USART1			1
+
+/* User serviceable stuff */
+#define CONFIG_DOS_PARTITION		1
+
+#define CONFIG_CMDLINE_TAG		1
+#define CONFIG_SETUP_MEMORY_TAGS	1
+#define CONFIG_INITRD_TAG		1
+
+#define CONFIG_STACKSIZE		(2048)
+
+#define CONFIG_BAUDRATE			115200
+#define CONFIG_BOOTARGS							\
+	"console=ttyS0 root=/dev/mtdblock1 rootfstype=jffs2"
+#define CONFIG_BOOTCOMMAND						\
+	"fsload; bootm"
+
+/*
+ * Only interrupt autoboot if <space> is pressed. Otherwise, garbage
+ * data on the serial line may interrupt the boot sequence.
+ */
+#define CONFIG_BOOTDELAY		1
+#define CONFIG_AUTOBOOT			1
+#define CONFIG_AUTOBOOT_KEYED		1
+#define CONFIG_AUTOBOOT_PROMPT				\
+        "Press SPACE to abort autoboot in %d seconds\n"
+#define CONFIG_AUTOBOOT_DELAY_STR	"d"
+#define CONFIG_AUTOBOOT_STOP_STR	" "
+
+/*
+ * After booting the board for the first time, new ethernet addresses
+ * should be generated and assigned to the environment variables
+ * "ethaddr" and "eth1addr". This is normally done during production.
+ */
+#define CONFIG_OVERWRITE_ETHADDR_ONCE	1
+#define CONFIG_NET_MULTI		1
+
+/*
+ * BOOTP/DHCP options
+ */
+#define CONFIG_BOOTP_SUBNETMASK
+#define CONFIG_BOOTP_GATEWAY
+
+#define CONFIG_DOS_PARTITION		1
+
+/*
+ * Command line configuration.
+ */
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_ASKENV
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_EXT2
+#define CONFIG_CMD_FAT
+#define CONFIG_CMD_JFFS2
+#define CONFIG_CMD_MMC
+#undef CONFIG_CMD_FPGA
+#undef CONFIG_CMD_SETGETDCR
+
+#define CONFIG_ATMEL_USART		1
+#define CONFIG_MACB			1
+#define CONFIG_PIO2			1
+#define CFG_NR_PIOS			5
+#define CFG_HSDRAMC			1
+#define CONFIG_MMC			1
+
+#define CFG_DCACHE_LINESZ		32
+#define CFG_ICACHE_LINESZ		32
+
+#define CONFIG_NR_DRAM_BANKS		1
+
+#define CFG_FLASH_BASE			0x00000000
+#define CFG_FLASH_SIZE			0x800000
+#define CFG_MAX_FLASH_BANKS		1
+#define CFG_MAX_FLASH_SECT		135
+
+#define CFG_MONITOR_BASE		CFG_FLASH_BASE
+
+#define CFG_INTRAM_BASE			0x24000000
+#define CFG_INTRAM_SIZE			0x8000
+
+#define CFG_SDRAM_BASE			0x10000000
+#define CFG_SDRAM_16BIT			1
+
+#define CFG_ENV_IS_IN_FLASH		1
+#define CFG_ENV_SIZE			65536
+#define CFG_ENV_ADDR			(CFG_FLASH_BASE + CFG_FLASH_SIZE - CFG_ENV_SIZE)
+
+#define CFG_INIT_SP_ADDR		(CFG_INTRAM_BASE + CFG_INTRAM_SIZE)
+
+#define CFG_MALLOC_LEN			(256*1024)
+#define CFG_MALLOC_END							\
+	({								\
+		DECLARE_GLOBAL_DATA_PTR;				\
+		CFG_SDRAM_BASE + gd->sdram_size;			\
+	})
+#define CFG_MALLOC_START		(CFG_MALLOC_END - CFG_MALLOC_LEN)
+
+#define CFG_DMA_ALLOC_LEN		(16384)
+
+/* Allow 4MB for the kernel run-time image */
+#define CFG_LOAD_ADDR			(CFG_SDRAM_BASE + 0x00400000)
+#define CFG_BOOTPARAMS_LEN		(16 * 1024)
+
+/* Other configuration settings that shouldn't have to change all that often */
+#define CFG_PROMPT			"Uboot> "
+#define CFG_CBSIZE			256
+#define CFG_MAXARGS			16
+#define CFG_PBSIZE			(CFG_CBSIZE + sizeof(CFG_PROMPT) + 16)
+#define CFG_LONGHELP			1
+
+#define CFG_MEMTEST_START						\
+	({ DECLARE_GLOBAL_DATA_PTR; gd->bd->bi_dram[0].start; })
+#define CFG_MEMTEST_END							\
+	({								\
+		DECLARE_GLOBAL_DATA_PTR;				\
+		gd->bd->bi_dram[0].start + gd->bd->bi_dram[0].size;	\
+	})
+#define CFG_BAUDRATE_TABLE { 115200, 38400, 19200, 9600, 2400 }
+
+#endif /* __CONFIG_H */
diff --git a/include/configs/atstk1002.h b/include/configs/atstk1002.h
index 1809fc5..b33e26f 100644
--- a/include/configs/atstk1002.h
+++ b/include/configs/atstk1002.h
@@ -114,15 +114,10 @@
 #define CONFIG_AUTOBOOT_STOP_STR	" "
 
 /*
- * These are "locally administered ethernet addresses" generated by
- * ./tools/gen_eth_addr
- *
- * After booting the board for the first time, new addresses should be
- * generated and assigned to the environment variables "ethaddr" and
- * "eth1addr".
+ * After booting the board for the first time, new ethernet addresses
+ * should be generated and assigned to the environment variables
+ * "ethaddr" and "eth1addr". This is normally done during production.
  */
-#define CONFIG_ETHADDR			6a:87:71:14:cd:cb
-#define CONFIG_ETH1ADDR			ca:f8:15:e6:3e:e6
 #define CONFIG_OVERWRITE_ETHADDR_ONCE	1
 #define CONFIG_NET_MULTI		1
 
diff --git a/include/configs/atstk1003.h b/include/configs/atstk1003.h
new file mode 100644
index 0000000..194788b
--- /dev/null
+++ b/include/configs/atstk1003.h
@@ -0,0 +1,184 @@
+/*
+ * Copyright (C) 2007 Atmel Corporation
+ *
+ * Configuration settings for the ATSTK1003 CPU daughterboard
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#define CONFIG_AVR32			1
+#define CONFIG_AT32AP			1
+#define CONFIG_AT32AP7001		1
+#define CONFIG_ATSTK1003		1
+#define CONFIG_ATSTK1000		1
+
+#define CONFIG_ATSTK1000_EXT_FLASH	1
+
+/*
+ * Timer clock frequency. We're using the CPU-internal COUNT register
+ * for this, so this is equivalent to the CPU core clock frequency
+ */
+#define CFG_HZ				1000
+
+/*
+ * Set up the PLL to run at 140 MHz, the CPU to run at the PLL
+ * frequency, the HSB and PBB at 1/2, and the PBA to run at 1/4 the
+ * PLL frequency.
+ * (CFG_OSC0_HZ * CFG_PLL0_MUL) / CFG_PLL0_DIV = PLL MHz
+ */
+#define CONFIG_PLL			1
+#define CFG_POWER_MANAGER		1
+#define CFG_OSC0_HZ			20000000
+#define CFG_PLL0_DIV			1
+#define CFG_PLL0_MUL			7
+#define CFG_PLL0_SUPPRESS_CYCLES	16
+/*
+ * Set the CPU running at:
+ * PLL / (2^CFG_CLKDIV_CPU) = CPU MHz
+ */
+#define CFG_CLKDIV_CPU			0
+/*
+ * Set the HSB running at:
+ * PLL / (2^CFG_CLKDIV_HSB) = HSB MHz
+ */
+#define CFG_CLKDIV_HSB			1
+/*
+ * Set the PBA running at:
+ * PLL / (2^CFG_CLKDIV_PBA) = PBA MHz
+ */
+#define CFG_CLKDIV_PBA			2
+/*
+ * Set the PBB running at:
+ * PLL / (2^CFG_CLKDIV_PBB) = PBB MHz
+ */
+#define CFG_CLKDIV_PBB			1
+
+/*
+ * The PLLOPT register controls the PLL like this:
+ *   icp = PLLOPT<2>
+ *   ivco = PLLOPT<1:0>
+ *
+ * We want icp=1 (default) and ivco=0 (80-160 MHz) or ivco=2 (150-240MHz).
+ */
+#define CFG_PLL0_OPT			0x04
+
+#undef CONFIG_USART0
+#define CONFIG_USART1			1
+#undef CONFIG_USART2
+#undef CONFIG_USART3
+
+/* User serviceable stuff */
+#define CONFIG_DOS_PARTITION		1
+
+#define CONFIG_CMDLINE_TAG		1
+#define CONFIG_SETUP_MEMORY_TAGS	1
+#define CONFIG_INITRD_TAG		1
+
+#define CONFIG_STACKSIZE		(2048)
+
+#define CONFIG_BAUDRATE			115200
+#define CONFIG_BOOTARGS							\
+	"console=ttyS0 root=/dev/mmcblk0p1 rootwait"
+
+#define CONFIG_BOOTCOMMAND						\
+	"mmcinit; ext2load mmc 0:1 0x10400000 /boot/uImage; bootm"
+
+/*
+ * Only interrupt autoboot if <space> is pressed. Otherwise, garbage
+ * data on the serial line may interrupt the boot sequence.
+ */
+#define CONFIG_BOOTDELAY		1
+#define CONFIG_AUTOBOOT			1
+#define CONFIG_AUTOBOOT_KEYED		1
+#define CONFIG_AUTOBOOT_PROMPT				\
+	"Press SPACE to abort autoboot in %d seconds\n"
+#define CONFIG_AUTOBOOT_DELAY_STR	"d"
+#define CONFIG_AUTOBOOT_STOP_STR	" "
+
+/*
+ * Command line configuration.
+ */
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_ASKENV
+#define CONFIG_CMD_EXT2
+#define CONFIG_CMD_FAT
+#define CONFIG_CMD_JFFS2
+#define CONFIG_CMD_MMC
+
+#undef CONFIG_CMD_FPGA
+#undef CONFIG_CMD_NET
+#undef CONFIG_CMD_NFS
+#undef CONFIG_CMD_SETGETDCR
+#undef CONFIG_CMD_XIMG
+
+#define CONFIG_ATMEL_USART		1
+#define CONFIG_PIO2			1
+#define CFG_HSDRAMC			1
+#define CONFIG_MMC			1
+
+#define CFG_DCACHE_LINESZ		32
+#define CFG_ICACHE_LINESZ		32
+
+#define CONFIG_NR_DRAM_BANKS		1
+
+/* External flash on STK1000 */
+#if 0
+#define CFG_FLASH_CFI			1
+#define CFG_FLASH_CFI_DRIVER		1
+#endif
+
+#define CFG_FLASH_BASE			0x00000000
+#define CFG_FLASH_SIZE			0x800000
+#define CFG_MAX_FLASH_BANKS		1
+#define CFG_MAX_FLASH_SECT		135
+
+#define CFG_MONITOR_BASE		CFG_FLASH_BASE
+
+#define CFG_INTRAM_BASE			0x24000000
+#define CFG_INTRAM_SIZE			0x8000
+
+#define CFG_SDRAM_BASE			0x10000000
+
+#define CFG_ENV_IS_IN_FLASH		1
+#define CFG_ENV_SIZE			65536
+#define CFG_ENV_ADDR			(CFG_FLASH_BASE + CFG_FLASH_SIZE - CFG_ENV_SIZE)
+
+#define CFG_INIT_SP_ADDR		(CFG_INTRAM_BASE + CFG_INTRAM_SIZE)
+
+#define CFG_MALLOC_LEN			(256*1024)
+
+/* Allow 4MB for the kernel run-time image */
+#define CFG_LOAD_ADDR			(CFG_SDRAM_BASE + 0x00400000)
+#define CFG_BOOTPARAMS_LEN		(16 * 1024)
+
+/* Other configuration settings that shouldn't have to change all that often */
+#define CFG_PROMPT			"Uboot> "
+#define CFG_CBSIZE			256
+#define CFG_MAXARGS			16
+#define CFG_PBSIZE			(CFG_CBSIZE + sizeof(CFG_PROMPT) + 16)
+#define CFG_LONGHELP			1
+
+#define CFG_MEMTEST_START		CFG_SDRAM_BASE
+#define CFG_MEMTEST_END			(CFG_MEMTEST_START + 0x700000)
+#define CFG_BAUDRATE_TABLE { 115200, 38400, 19200, 9600, 2400 }
+
+#endif /* __CONFIG_H */
diff --git a/include/configs/atstk1004.h b/include/configs/atstk1004.h
new file mode 100644
index 0000000..1bad171
--- /dev/null
+++ b/include/configs/atstk1004.h
@@ -0,0 +1,185 @@
+/*
+ * Copyright (C) 2007 Atmel Corporation
+ *
+ * Configuration settings for the ATSTK1003 CPU daughterboard
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#define CONFIG_AVR32			1
+#define CONFIG_AT32AP			1
+#define CONFIG_AT32AP7002		1
+#define CONFIG_ATSTK1004		1
+#define CONFIG_ATSTK1000		1
+
+#define CONFIG_ATSTK1000_EXT_FLASH	1
+
+/*
+ * Timer clock frequency. We're using the CPU-internal COUNT register
+ * for this, so this is equivalent to the CPU core clock frequency
+ */
+#define CFG_HZ				1000
+
+/*
+ * Set up the PLL to run at 140 MHz, the CPU to run at the PLL
+ * frequency, the HSB and PBB at 1/2, and the PBA to run at 1/4 the
+ * PLL frequency.
+ * (CFG_OSC0_HZ * CFG_PLL0_MUL) / CFG_PLL0_DIV = PLL MHz
+ */
+#define CONFIG_PLL			1
+#define CFG_POWER_MANAGER		1
+#define CFG_OSC0_HZ			20000000
+#define CFG_PLL0_DIV			1
+#define CFG_PLL0_MUL			7
+#define CFG_PLL0_SUPPRESS_CYCLES	16
+/*
+ * Set the CPU running at:
+ * PLL / (2^CFG_CLKDIV_CPU) = CPU MHz
+ */
+#define CFG_CLKDIV_CPU			0
+/*
+ * Set the HSB running at:
+ * PLL / (2^CFG_CLKDIV_HSB) = HSB MHz
+ */
+#define CFG_CLKDIV_HSB			1
+/*
+ * Set the PBA running at:
+ * PLL / (2^CFG_CLKDIV_PBA) = PBA MHz
+ */
+#define CFG_CLKDIV_PBA			2
+/*
+ * Set the PBB running at:
+ * PLL / (2^CFG_CLKDIV_PBB) = PBB MHz
+ */
+#define CFG_CLKDIV_PBB			1
+
+/*
+ * The PLLOPT register controls the PLL like this:
+ *   icp = PLLOPT<2>
+ *   ivco = PLLOPT<1:0>
+ *
+ * We want icp=1 (default) and ivco=0 (80-160 MHz) or ivco=2 (150-240MHz).
+ */
+#define CFG_PLL0_OPT			0x04
+
+#undef CONFIG_USART0
+#define CONFIG_USART1			1
+#undef CONFIG_USART2
+#undef CONFIG_USART3
+
+/* User serviceable stuff */
+#define CONFIG_DOS_PARTITION		1
+
+#define CONFIG_CMDLINE_TAG		1
+#define CONFIG_SETUP_MEMORY_TAGS	1
+#define CONFIG_INITRD_TAG		1
+
+#define CONFIG_STACKSIZE		(2048)
+
+#define CONFIG_BAUDRATE			115200
+#define CONFIG_BOOTARGS							\
+	"console=ttyS0 root=/dev/mmcblk0p1 rootwait"
+
+#define CONFIG_BOOTCOMMAND						\
+	"mmcinit; ext2load mmc 0:1 0x10200000 /boot/uImage; bootm"
+
+/*
+ * Only interrupt autoboot if <space> is pressed. Otherwise, garbage
+ * data on the serial line may interrupt the boot sequence.
+ */
+#define CONFIG_BOOTDELAY		1
+#define CONFIG_AUTOBOOT			1
+#define CONFIG_AUTOBOOT_KEYED		1
+#define CONFIG_AUTOBOOT_PROMPT				\
+	"Press SPACE to abort autoboot in %d seconds\n"
+#define CONFIG_AUTOBOOT_DELAY_STR	"d"
+#define CONFIG_AUTOBOOT_STOP_STR	" "
+
+/*
+ * Command line configuration.
+ */
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_ASKENV
+#define CONFIG_CMD_EXT2
+#define CONFIG_CMD_FAT
+#define CONFIG_CMD_JFFS2
+#define CONFIG_CMD_MMC
+
+#undef CONFIG_CMD_FPGA
+#undef CONFIG_CMD_NET
+#undef CONFIG_CMD_NFS
+#undef CONFIG_CMD_SETGETDCR
+#undef CONFIG_CMD_XIMG
+
+#define CONFIG_ATMEL_USART		1
+#define CONFIG_PIO2			1
+#define CFG_HSDRAMC			1
+#define CONFIG_MMC			1
+
+#define CFG_DCACHE_LINESZ		32
+#define CFG_ICACHE_LINESZ		32
+
+#define CONFIG_NR_DRAM_BANKS		1
+
+/* External flash on STK1000 */
+#if 0
+#define CFG_FLASH_CFI			1
+#define CFG_FLASH_CFI_DRIVER		1
+#endif
+
+#define CFG_FLASH_BASE			0x00000000
+#define CFG_FLASH_SIZE			0x800000
+#define CFG_MAX_FLASH_BANKS		1
+#define CFG_MAX_FLASH_SECT		135
+
+#define CFG_MONITOR_BASE		CFG_FLASH_BASE
+
+#define CFG_INTRAM_BASE			0x24000000
+#define CFG_INTRAM_SIZE			0x8000
+
+#define CFG_SDRAM_BASE			0x10000000
+#define CFG_SDRAM_16BIT			1
+
+#define CFG_ENV_IS_IN_FLASH		1
+#define CFG_ENV_SIZE			65536
+#define CFG_ENV_ADDR			(CFG_FLASH_BASE + CFG_FLASH_SIZE - CFG_ENV_SIZE)
+
+#define CFG_INIT_SP_ADDR		(CFG_INTRAM_BASE + CFG_INTRAM_SIZE)
+
+#define CFG_MALLOC_LEN			(256*1024)
+
+/* Allow 4MB for the kernel run-time image */
+#define CFG_LOAD_ADDR			(CFG_SDRAM_BASE + 0x00200000)
+#define CFG_BOOTPARAMS_LEN		(16 * 1024)
+
+/* Other configuration settings that shouldn't have to change all that often */
+#define CFG_PROMPT			"Uboot> "
+#define CFG_CBSIZE			256
+#define CFG_MAXARGS			16
+#define CFG_PBSIZE			(CFG_CBSIZE + sizeof(CFG_PROMPT) + 16)
+#define CFG_LONGHELP			1
+
+#define CFG_MEMTEST_START		CFG_SDRAM_BASE
+#define CFG_MEMTEST_END			(CFG_MEMTEST_START + 0x700000)
+#define CFG_BAUDRATE_TABLE { 115200, 38400, 19200, 9600, 2400 }
+
+#endif /* __CONFIG_H */
diff --git a/include/configs/delta.h b/include/configs/delta.h
index 09667ed..14fde1a 100644
--- a/include/configs/delta.h
+++ b/include/configs/delta.h
@@ -123,6 +123,8 @@
 #define CONFIG_USB_STORAGE      1
 #define CONFIG_DOS_PARTITION    1
 
+#include <asm/arch/pxa-regs.h> /* for OHCI_REGS_BASE */
+
 #undef CFG_USB_OHCI_BOARD_INIT
 #define CFG_USB_OHCI_CPU_INIT	1
 #define CFG_USB_OHCI_REGS_BASE	OHCI_REGS_BASE
diff --git a/include/configs/lubbock.h b/include/configs/lubbock.h
index 4adf254..82fe19c 100644
--- a/include/configs/lubbock.h
+++ b/include/configs/lubbock.h
@@ -42,6 +42,7 @@
 #endif
 #define CONFIG_MMC		1
 #define BOARD_LATE_INIT		1
+#define CONFIG_DOS_PARTITION
 
 #undef CONFIG_USE_IRQ			/* we don't need IRQ/FIQ stuff */
 
diff --git a/include/configs/motionpro.h b/include/configs/motionpro.h
index 9a21632..1503598 100644
--- a/include/configs/motionpro.h
+++ b/include/configs/motionpro.h
@@ -163,9 +163,9 @@
 
 
 /*
- * Clock configuration: SYS_XTALIN = 25MHz
+ * Clock configuration: SYS_XTALIN = 33MHz
  */
-#define CFG_MPC5XXX_CLKIN	25000000
+#define CFG_MPC5XXX_CLKIN	33000000
 
 
 /*
@@ -211,7 +211,7 @@
 #endif
 
 #define CFG_MONITOR_LEN		(256 << 10)	/* 256 kB for Monitor */
-#define CFG_MALLOC_LEN		(128 << 10)	/* 128 kB for malloc() */
+#define CFG_MALLOC_LEN		(1024 << 10)	/* 1 MiB for malloc() */
 #define CFG_BOOTMAPSZ		(8 << 20)	/* initial mem map for Linux */
 
 
@@ -221,7 +221,7 @@
 /* Boot Chipselect */
 #define CFG_BOOTCS_START	CFG_FLASH_BASE
 #define CFG_BOOTCS_SIZE		CFG_FLASH_SIZE
-#define CFG_BOOTCS_CFG		0x03035D00
+#define CFG_BOOTCS_CFG		0x00045D00
 
 /* Flash memory addressing */
 #define CFG_CS0_START		CFG_FLASH_BASE
@@ -251,11 +251,11 @@
 /*
  * SDRAM configuration
  */
-/* 2 x MT48LC16M16A2BG-75 IT:D, CASL 2, 32 bit data bus */
-#define SDRAM_CONFIG1		0x52222600
-#define SDRAM_CONFIG2		0x88b70000
-#define SDRAM_CONTROL		0x50570000
-#define SDRAM_MODE		0x008d0000
+/* 2 x MT48LC16M16A2BG-75 IT:D, CASL 3, 32 bit data bus */
+#define SDRAM_CONFIG1		0x62322900
+#define SDRAM_CONFIG2		0x88c70000
+#define SDRAM_CONTROL		0x504f0000
+#define SDRAM_MODE		0x00cd0000
 
 
 /*
@@ -267,7 +267,7 @@
 #define CFG_FLASH_SIZE		0x01000000
 #define CFG_MAX_FLASH_BANKS	1	/* max num of memory banks */
 #define CFG_FLASH_BANKS_LIST	{ CFG_FLASH_BASE }
-#define CFG_MAX_FLASH_SECT	256	/* max num of sects on one chip */
+#define CFG_MAX_FLASH_SECT	128	/* max num of sects on one chip */
 #define CONFIG_FLASH_16BIT		/* Flash is 16-bit */
 
 /*
@@ -277,8 +277,8 @@
 #define MTDIDS_DEFAULT		"nor0=motionpro-0"
 #define MTDPARTS_DEFAULT	"mtdparts=motionpro-0:"			  \
 					"13m(fs),2m(kernel),256k(uboot)," \
-					"64k(env),64k(redund_env),64k(dtb)," \
-					"-(user_data)"
+					"128k(env),128k(redund_env),"	  \
+					"128k(dtb),-(user_data)"
 
 /*
  * IDE/ATA configuration
@@ -356,7 +356,7 @@ extern void __led_set(led_id_t id, int state);
 /* This has to be a multiple of the Flash sector size */
 #define CFG_ENV_ADDR		(CFG_MONITOR_BASE + CFG_MONITOR_LEN)
 #define CFG_ENV_SIZE		0x1000
-#define CFG_ENV_SECT_SIZE	0x10000
+#define CFG_ENV_SECT_SIZE	0x20000
 
 /* Configuration of redundant environment */
 #define CFG_ENV_ADDR_REDUND	(CFG_ENV_ADDR + CFG_ENV_SECT_SIZE)
@@ -394,7 +394,8 @@ extern void __led_set(led_id_t id, int state);
 #define CFG_BARGSIZE		CFG_CBSIZE	/* Boot Argument Buffer Size */
 
 #define CFG_MEMTEST_START	0x00100000	/* memtest works on */
-#define CFG_MEMTEST_END		0x03f00000	/* 1 ... 64 MiB in DRAM */
+#define CFG_MEMTEST_END		0x03e00000	/* 1 ... 62 MiB in DRAM */
+#define CFG_ALT_MEMTEST
 
 #define CFG_LOAD_ADDR		0x200000	/* default kernel load addr */
 
diff --git a/include/configs/pxa255_idp.h b/include/configs/pxa255_idp.h
index 0e884fc..4a9cadb 100644
--- a/include/configs/pxa255_idp.h
+++ b/include/configs/pxa255_idp.h
@@ -38,10 +38,11 @@
 #include <asm/arch/pxa-regs.h>
 
 /*
- * If we are developing, we might want to start armboot from ram
+ * If we are developing, we might want to start U-Boot from RAM
  * so we MUST NOT initialize critical regs like mem-timing ...
  */
-#define CONFIG_INIT_CRITICAL			/* undef for developing */
+#undef CONFIG_SKIP_LOWLEVEL_INIT			/* define for developing */
+#undef CONFIG_SKIP_RELOCATE_UBOOT			/* define for developing */
 
 /*
  * define the following to enable debug blinks.  A debug blink function
@@ -62,6 +63,7 @@
 #endif
 
 #define CONFIG_MMC		1
+#define CONFIG_DOS_PARTITION	1
 #define BOARD_LATE_INIT		1
 
 #undef CONFIG_USE_IRQ			/* we don't need IRQ/FIQ stuff */
@@ -121,7 +123,6 @@
 #define CONFIG_CMD_FAT
 #define CONFIG_CMD_DHCP
 
-
 #define CONFIG_BOOTDELAY	3
 #define CONFIG_BOOTCOMMAND	"bootm 40000"
 #define CONFIG_BOOTARGS		"root=/dev/mtdblock2 rootfstype=cramfs console=ttyS0,115200"
@@ -332,7 +333,7 @@
 #define CFG_FLASH_CFI_DRIVER	1
 
 #define CFG_MONITOR_BASE	0
-#define CFG_MONITOR_LEN		0x40000
+#define CFG_MONITOR_LEN		PHYS_FLASH_SECT_SIZE
 
 #define CFG_MAX_FLASH_BANKS	1	/* max number of memory banks		*/
 #define CFG_MAX_FLASH_SECT	128  /* max number of sectors on one chip    */
@@ -347,7 +348,7 @@
 #define CFG_ENV_IS_IN_FLASH	1
  /* Addr of Environment Sector	*/
 #define CFG_ENV_ADDR		(PHYS_FLASH_1 + PHYS_FLASH_SIZE - 0x40000)
-#define CFG_ENV_SIZE		0x40000	/* Total Size of Environment Sector	*/
-#define	CFG_ENV_SECT_SIZE	0x40000
+#define CFG_ENV_SIZE		PHYS_FLASH_SECT_SIZE	/* Total Size of Environment Sector	*/
+#define	CFG_ENV_SECT_SIZE	(PHYS_FLASH_SECT_SIZE / 16)
 
 #endif	/* __CONFIG_H */
diff --git a/include/configs/sequoia.h b/include/configs/sequoia.h
index c2e1386..600f98c 100644
--- a/include/configs/sequoia.h
+++ b/include/configs/sequoia.h
@@ -450,6 +450,8 @@
 #define CFG_EBC_PB2AP		0x24814580
 #define CFG_EBC_PB2CR		(CFG_BCSR_BASE | 0x38000)
 
+#define CFG_BCSR5_PCI66EN	0x80
+
 /*-----------------------------------------------------------------------
  * NAND FLASH
  *----------------------------------------------------------------------*/
diff --git a/include/configs/xsengine.h b/include/configs/xsengine.h
index 5733933..766617e 100644
--- a/include/configs/xsengine.h
+++ b/include/configs/xsengine.h
@@ -32,6 +32,7 @@
 #define CONFIG_PXA250			1		/* This is an PXA250 CPU    */
 #define CONFIG_XSENGINE			1
 #define CONFIG_MMC			1
+#define CONFIG_DOS_PARTITION		1
 #define BOARD_POST_INIT			1
 #undef  CONFIG_USE_IRQ					/* we don't need IRQ/FIQ stuff */
 #define CFG_HZ				3686400		/* incrementer freq: 3.6864 MHz */
diff --git a/include/configs/xupv2p.h b/include/configs/xupv2p.h
index b1c0ee6..c9320c2 100644
--- a/include/configs/xupv2p.h
+++ b/include/configs/xupv2p.h
@@ -31,7 +31,7 @@
 #define	CONFIG_XUPV2P		1
 
 /* uart */
-#define CONFIG_XILINX_UARTLITE
+#define	CONFIG_XILINX_UARTLITE
 #define	CONFIG_SERIAL_BASE	XILINX_UART_BASEADDR
 #define	CONFIG_BAUDRATE		XILINX_UART_BAUDRATE
 #define	CFG_BAUDRATE_TABLE	{ CONFIG_BAUDRATE }
@@ -49,11 +49,13 @@
  * U-BOOT auto-relocate to TEXT_BASE. After RESET command Microblaze
  * jump to CFG_RESET_ADDRESS where is the original U-BOOT code.
  */
-#define	CFG_RESET_ADDRESS	0x36000000
+/* #define	CFG_RESET_ADDRESS	0x36000000 */
 
 /* gpio */
+#ifdef XILINX_GPIO_BASEADDR
 #define	CFG_GPIO_0		1
 #define	CFG_GPIO_0_ADDR		XILINX_GPIO_BASEADDR
+#endif
 
 /* interrupt controller */
 #define	CFG_INTC_0		1
@@ -66,6 +68,7 @@
 #define	CFG_TIMER_0_IRQ		XILINX_TIMER_IRQ
 #define	FREQUENCE		XILINX_CLOCK_FREQ
 #define	CFG_TIMER_0_PRELOAD	( FREQUENCE/1000 )
+#define	CONFIG_XILINX_CLOCK_FREQ	XILINX_CLOCK_FREQ
 
 /*
  * memory layout - Example
@@ -120,7 +123,6 @@
 #define	CFG_ENV_SIZE		0x1000
 #define	CFG_ENV_ADDR		(CFG_MONITOR_BASE - CFG_ENV_SIZE)
 
-
 /*
  * BOOTP options
  */
@@ -129,29 +131,23 @@
 #define CONFIG_BOOTP_GATEWAY
 #define CONFIG_BOOTP_HOSTNAME
 
-
 /*
  * Command line configuration.
  */
 #include <config_cmd_default.h>
 
-#define CONFIG_CMD_MEMORY
-#define CONFIG_CMD_IRQ
-#define CONFIG_CMD_BDI
-#define CONFIG_CMD_NET
-#define CONFIG_CMD_IMI
-#define CONFIG_CMD_ECHO
-#define CONFIG_CMD_CACHE
-#define CONFIG_CMD_RUN
-#define CONFIG_CMD_AUTOSCRIPT
+#undef CONFIG_CMD_FLASH
+#undef CONFIG_CMD_IMLS
+
 #define CONFIG_CMD_ASKENV
-#define CONFIG_CMD_LOADS
-#define CONFIG_CMD_LOADB
-#define CONFIG_CMD_MISC
-#define CONFIG_CMD_FAT
-#define CONFIG_CMD_EXT2
+#define CONFIG_CMD_CACHE
+#define CONFIG_CMD_IRQ
 #define CONFIG_CMD_PING
 
+#ifdef XILINX_SYSACE_BASEADDR
+#define CONFIG_CMD_EXT2
+#define CONFIG_CMD_FAT
+#endif
 
 /* Miscellaneous configurable options */
 #define	CFG_PROMPT	"U-Boot-mONStR> "
@@ -163,7 +159,7 @@
 
 #define	CONFIG_BOOTDELAY 	30
 #define	CONFIG_BOOTARGS		"root=romfs"
-#define	CONFIG_HOSTNAME		"ml401"
+#define	CONFIG_HOSTNAME		"xupv2p"
 #define	CONFIG_BOOTCOMMAND 	"base 0;tftp 11000000 image.img;bootm"
 #define	CONFIG_IPADDR		192.168.0.3
 #define	CONFIG_SERVERIP 	192.168.0.5
@@ -179,11 +175,13 @@
 	"echo"
 
 /* system ace */
+#ifdef XILINX_SYSACE_BASEADDR
 #define	CONFIG_SYSTEMACE
 /* #define DEBUG_SYSTEMACE */
 #define	SYSTEMACE_CONFIG_FPGA
 #define	CFG_SYSTEMACE_BASE	XILINX_SYSACE_BASEADDR
 #define	CFG_SYSTEMACE_WIDTH	XILINX_SYSACE_MEM_WIDTH
 #define	CONFIG_DOS_PARTITION
+#endif
 
 #endif	/* __CONFIG_H */
diff --git a/include/configs/yosemite.h b/include/configs/yosemite.h
index 6a5b7f1..35bce4a 100644
--- a/include/configs/yosemite.h
+++ b/include/configs/yosemite.h
@@ -359,6 +359,8 @@
 #define CFG_EBC_PB2AP		0x04814500
 #define CFG_EBC_PB2CR		(CFG_CPLD | 0x18000)
 
+#define CFG_BCSR5_PCI66EN	0x80
+
 /*-----------------------------------------------------------------------
  * Cache Configuration
  */
diff --git a/include/part.h b/include/part.h
index 29c0320..37b2b68 100644
--- a/include/part.h
+++ b/include/part.h
@@ -38,9 +38,9 @@ typedef struct block_dev_desc {
 #endif
 	lbaint_t		lba;	  	/* number of blocks */
 	unsigned long	blksz;		/* block size */
-	unsigned char	vendor [40+1]; 	/* IDE model, SCSI Vendor */
-	unsigned char	product[20+1];	/* IDE Serial no, SCSI product */
-	unsigned char	revision[8+1];	/* firmware revision */
+	char		vendor [40+1]; 	/* IDE model, SCSI Vendor */
+	char		product[20+1];	/* IDE Serial no, SCSI product */
+	char		revision[8+1];	/* firmware revision */
 	unsigned long	(*block_read)(int dev,
 				      unsigned long start,
 				      lbaint_t blkcnt,
diff --git a/net/eth.c b/net/eth.c
index e7f1220..0fee6b3 100644
--- a/net/eth.c
+++ b/net/eth.c
@@ -59,6 +59,7 @@ extern int npe_initialize(bd_t *);
 extern int uec_initialize(int);
 extern int bfin_EMAC_initialize(bd_t *);
 extern int atstk1000_eth_initialize(bd_t *);
+extern int atngw100_eth_initialize(bd_t *);
 extern int mcffec_initialize(bd_t*);
 
 static struct eth_device *eth_devices, *eth_current;
@@ -250,6 +251,9 @@ int eth_initialize(bd_t *bis)
 #if defined(CONFIG_ATSTK1000)
 	atstk1000_eth_initialize(bis);
 #endif
+#if defined(CONFIG_ATNGW100)
+	atngw100_eth_initialize(bis);
+#endif
 #if defined(CONFIG_MCFFEC)
 	mcffec_initialize(bis);
 #endif
